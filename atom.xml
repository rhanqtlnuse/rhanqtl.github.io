<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RHANQTL</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-02T07:26:15.487Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Han Qi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象软件设计：设计模式</title>
    <link href="http://yoursite.com/2019/01/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/01/02/面向对象软件设计：设计模式/</id>
    <published>2019-01-02T05:02:06.000Z</published>
    <updated>2019-01-02T07:26:15.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式综述"><a href="#设计模式综述" class="headerlink" title="设计模式综述"></a>设计模式综述</h1><p>着眼于 “变化”</p><a id="more"></a><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><img src="/2019/01/02/面向对象软件设计：设计模式/strategy-pattern.png"><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><img src="/2019/01/02/面向对象软件设计：设计模式/factory-method-pattern.png"><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] Design Pattern</p><p>[2] Head First Design Pattern</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式综述&quot;&gt;&lt;a href=&quot;#设计模式综述&quot; class=&quot;headerlink&quot; title=&quot;设计模式综述&quot;&gt;&lt;/a&gt;设计模式综述&lt;/h1&gt;&lt;p&gt;着眼于 “变化”&lt;/p&gt;
    
    </summary>
    
      <category term="Design" scheme="http://yoursite.com/categories/Design/"/>
    
      <category term="OOP" scheme="http://yoursite.com/categories/Design/OOP/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象软件设计：设计原则</title>
    <link href="http://yoursite.com/2019/01/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%9A%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/01/02/面向对象软件设计：设计原则/</id>
    <published>2019-01-02T03:26:04.000Z</published>
    <updated>2019-01-02T07:29:19.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计原则综述"><a href="#设计原则综述" class="headerlink" title="设计原则综述"></a>设计原则综述</h1><a id="more"></a><h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>最重要的原则</p><p>关键是 “抽象化”</p><h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><p>使用基类的地方应该都能够使用子类代替，而无需了解子类的细节，反之不成立</p><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>依赖注入</p><ul><li>构造注入</li><li>设值注入</li><li>接口注入</li></ul><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>针对接口编程，不要针对实现编程</p><ul><li>“接口” 并不是某个语言中的语法特性（比如 Java 的 <code>interface</code>）而是合约（方法）</li></ul><h1 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h1><p>也叫 “组合/聚合复用原则”</p><h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><p>也叫 “最少知识原则”</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计原则综述&quot;&gt;&lt;a href=&quot;#设计原则综述&quot; class=&quot;headerlink&quot; title=&quot;设计原则综述&quot;&gt;&lt;/a&gt;设计原则综述&lt;/h1&gt;
    
    </summary>
    
      <category term="Design" scheme="http://yoursite.com/categories/Design/"/>
    
      <category term="OOP" scheme="http://yoursite.com/categories/Design/OOP/"/>
    
    
  </entry>
  
  <entry>
    <title>软件测试基础：逻辑覆盖法</title>
    <link href="http://yoursite.com/2019/01/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%B3%95/"/>
    <id>http://yoursite.com/2019/01/02/软件测试基础：逻辑覆盖法/</id>
    <published>2019-01-02T02:45:06.000Z</published>
    <updated>2019-01-02T02:45:06.973Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C++ STL：lower_bound() 与 upper_bound()</title>
    <link href="http://yoursite.com/2019/01/01/C-STL%EF%BC%9Alower-bound-%E4%B8%8E-upper-bound/"/>
    <id>http://yoursite.com/2019/01/01/C-STL：lower-bound-与-upper-bound/</id>
    <published>2018-12-31T16:12:20.000Z</published>
    <updated>2018-12-31T16:39:15.344Z</updated>
    
    <content type="html"><![CDATA[<p>头文件 <code>&lt;algorithm&gt;</code> 中，<code>lower_bound()</code> 和 <code>upper_bound()</code> 主要是用来在一个有序序列中查找一个元素第一次出现的位置和最后一次出现的位置的后一个位置（这个的原因 E.W.D. 论证过，详见参考 [1]）。一看到“有序序列”，自然第一反应就是使用二分查找。但是我们平时的二分查找通常是三个分支：大于 key，小于 key，等于 key。所以需要进行一些小小的修改。</p><h1 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound()"></a><code>lower_bound()</code></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> size, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = size;</span><br><span class="line">    <span class="keyword">int</span> middle, half;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        middle = first + half;</span><br><span class="line">        <span class="keyword">if</span> (a[middle] &lt; key) &#123;</span><br><span class="line">            first = middle + <span class="number">1</span>;</span><br><span class="line">            len = len - half - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = half;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound()"></a><code>upper_bound()</code></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> size, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = size;</span><br><span class="line">    <span class="keyword">int</span> half, middle;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        middle = first + half;</span><br><span class="line">        <span class="keyword">if</span> (a[middle] &gt; key) &#123;</span><br><span class="line">            len = half;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            first = middle + <span class="number">1</span>;</span><br><span class="line">            len - len - half - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较一下这两个方法，几乎是对称的，真的很精巧！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html" target="_blank" rel="noopener">EWD831: Why Numbering Should Start At Zero</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;头文件 &lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt; 中，&lt;code&gt;lower_bound()&lt;/code&gt; 和 &lt;code&gt;upper_bound()&lt;/code&gt; 主要是用来在一个有序序列中查找一个元素第一次出现的位置和最后一次出现的位置的后一个位置（
      
    
    </summary>
    
      <category term="Programming Languages" scheme="http://yoursite.com/categories/Programming-Languages/"/>
    
      <category term="C++" scheme="http://yoursite.com/categories/Programming-Languages/C/"/>
    
    
  </entry>
  
  <entry>
    <title>温习 C 语言：数组 &amp; 指针</title>
    <link href="http://yoursite.com/2018/12/31/%E6%B8%A9%E4%B9%A0-C-%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2018/12/31/温习-C-语言：数组-指针/</id>
    <published>2018-12-31T15:07:30.000Z</published>
    <updated>2018-12-31T15:12:03.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在-C-中动态创建数组"><a href="#在-C-中动态创建数组" class="headerlink" title="在 C 中动态创建数组"></a>在 C 中动态创建数组</h2><p>使用 <code>malloc</code> 函数</p><ul><li><p>一维数组（n 个元素）</p><ul><li><p>创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure></li><li><p>销毁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二维数组（m 行 n 列）</p><ul><li><p>创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **a = (<span class="keyword">int</span> **) <span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    a[i] = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>销毁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在-C-中动态创建数组&quot;&gt;&lt;a href=&quot;#在-C-中动态创建数组&quot; class=&quot;headerlink&quot; title=&quot;在 C 中动态创建数组&quot;&gt;&lt;/a&gt;在 C 中动态创建数组&lt;/h2&gt;&lt;p&gt;使用 &lt;code&gt;malloc&lt;/code&gt; 函数&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="Programming Languages" scheme="http://yoursite.com/categories/Programming-Languages/"/>
    
      <category term="C" scheme="http://yoursite.com/categories/Programming-Languages/C/"/>
    
    
  </entry>
  
  <entry>
    <title>POJ 3061：Subsequence</title>
    <link href="http://yoursite.com/2018/12/31/POJ-3061%EF%BC%9ASubsequence/"/>
    <id>http://yoursite.com/2018/12/31/POJ-3061：Subsequence/</id>
    <published>2018-12-31T15:00:43.000Z</published>
    <updated>2018-12-31T15:15:43.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Subsequence"><a href="#Subsequence" class="headerlink" title="Subsequence"></a>Subsequence</h1><p><strong>Time Limit:</strong> 1000MS</p><p><strong>Memory Limit:</strong> 65536K</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>A sequence of N positive integers (10 &lt; N &lt; 100 000), each of them less than or equal 10000, and a positive integer S (S &lt; 100 000 000) are given. Write a program to find the minimal length of the subsequence of consecutive elements of the sequence, the sum of which is greater than or equal to S.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line is the number of test cases. For each test case the program has to read the numbers N and S, separated by an interval, from the first line. The numbers of the sequence are given in the second line of the test case, separated by intervals. The input will finish with the end of file.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each the case the program has to print the result on separate line of the output file.if no answer, print 0.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">10 15</span><br><span class="line">5 1 3 5 10 7 4 9 2 8</span><br><span class="line">5 11</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p><a href="http://poj.org/searchproblem?field=source&amp;key=Southeastern+Europe+2006" target="_blank" rel="noopener">Southeastern Europe 2006</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Subsequence&quot;&gt;&lt;a href=&quot;#Subsequence&quot; class=&quot;headerlink&quot; title=&quot;Subsequence&quot;&gt;&lt;/a&gt;Subsequence&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Time Limit:&lt;/strong&gt; 1000M
      
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
      <category term="OJ" scheme="http://yoursite.com/categories/Algorithms/OJ/"/>
    
      <category term="POJ" scheme="http://yoursite.com/categories/Algorithms/OJ/POJ/"/>
    
    
  </entry>
  
  <entry>
    <title>10x 程序员</title>
    <link href="http://yoursite.com/2018/12/30/10x-%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    <id>http://yoursite.com/2018/12/30/10x-程序员/</id>
    <published>2018-12-30T14:43:52.000Z</published>
    <updated>2018-12-30T14:45:03.446Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="http://antirez.com/news/112" target="_blank" rel="noopener"><antirez></antirez></a></p><h2 id="The-mythical-10x-programmer"><a href="#The-mythical-10x-programmer" class="headerlink" title="The mythical 10x programmer"></a>The mythical 10x programmer</h2><p>antirez 670 days ago. 543210 views.A 10x programmer is, in the mythology of programming, a programmer that can do ten times the work of another normal programmer, where for normal programmer we can imagine one good at doing its work, but without the magical abilities of the 10x programmer. Actually to better characterize the “normal programmer” it is better to say that it represents the one having the average programming output, among the programmers that are professionals in this discipline.</p><p>The programming community is extremely polarized about the existence or not of such a beast: who says there is no such a thing as the 10x programmer, who says it actually does not just exist, but there are even 100x programmers if you know where to look for.</p><p>If you see programming as a “linear” discipline, it is clear that the 10x programmer looks like an irrational possibility. How can a runner run 10x faster than another one? Or a construction worker build 10x the things another worker can build in the same time? However programming is a design discipline, in a very special way. Even when a programmer does not participate in the actual architectural design of a program, the act of implementing it still requires a sub-design of the implementation strategy.</p><p>So if the design and implementation of a program are not linear abilities, things like experience, coding abilities, knowledge, recognition of useless parts, are, in my opinion, not just linear advantages, they work together in a multiplicative way in the act of creating a program. Of course this phenomenon happens much more when a programmer can both handle the design and the implementation of a program. The more “goal oriented” is the task, the more a potential 10x programmer can exploit her/his abilities in order to reach the goal with a lot less efforts. When the task at hand is much more rigid, with specific guidelines about what tools to use and how to implement things, the ability of a 10x programmer to perform a lot of work in less time is weakened: it can still exploit “local” design possibilities to do a much better work, but cannot change in more profound ways the path used to reach the goal, that may include, possibly, even eliminating part of the specification completely from the project, so that the goal to be reached looks almost the same but the efforts to reach it are reduced by a big factor.</p><p>In twenty years of working as a programmer I observed other programmers working with me, as coworkers, guided by me in order to reach a given goal, providing patches to Redis and other projects. At the same time many people told me that they believe I’m a very fast programmer. Considering I’m far from being a workaholic, I’ll also use myself as a reference of coding things fast.</p><p>The following is a list of qualities that I believe make the most difference in programmers productivity.</p><ul><li>Bare programming abilities: getting sub-tasks done</li></ul><p>One of the most obvious limits, or strengths, of a programmer is to deal with the sub-task of actually implementing part of a program: a function, an algorithm or whatever. Surprisingly the ability to use basic imperative programming constructs very efficiently in order to implement something is, in my experience, not as widespread as one may think. In a team sometimes I observed very incompetent programmers, that were not even aware of a simple sorting algorithm, to get more work done than graduated programmers that were in theory extremely competent but very poor in the practice of implementing solutions.</p><ul><li>Experience: pattern matching</li></ul><p>By experience I mean the set of already explored solutions for a number of recurring tasks. An experienced programmer eventually knows how to deal with a variety of sub tasks. This avoids both a lot of design work, but especially, is an extremely powerful weapon against design errors, that are in turn among the biggest enemies of simplicity.</p><ul><li>Focus: actual time VS hypothetical time</li></ul><p>The number of hours spent writing code is irrelevant without looking at the quality of the time. Lack of focus can be generated by internal and external factors. Internal factors are procrastination, lack of interest in the project at hand (you can’t be good doing things you do not love), lack of exercise / well-being, poor or little sleeping. External factors are frequent meetings, work environments without actual offices, coworkers interrupting often and so forth. It seems natural that trying to improve focus and to reduce interruptions is going to have a non marginal effect on the programming productivity. Sometimes in order to gain focus, extreme measures are needed. For instance I only read emails from time to time and do not reply to most of them.</p><ul><li>Design sacrifice: killing 5% to get 90%</li></ul><p>Often complexity is generated when there is no willingness to recognized that a non fundamental goal of a project is accounting for a very large amount of design complexity, or is making another more important goal very hard to reach, because there is a design tension among a fundamental feature and a non fundamental one. It is very important for a designer to recognize all the parts of a design that are not easy wins, that is, there is no proportionality between the effort and the advantages. A project that is executed in order to maximize the output, is going to focus exactly on the aspects that matter and that can be implemented in a reasonable amount of time. For example when designing Disque, a message broker, at some point I realized that by providing just best-effort ordering for the messages, all the other aspects of the project could be substantially improved: availability, query language and clients interaction, simplicity and performances.</p><ul><li>Simplicity</li></ul><p>This is an obvious point that means all and nothing. In order to understand what simplicity is, it is worth to check how complexity is often generated. I believe that the two main drivers of complexity are the unwillingness to perform design sacrifices, and the accumulation of errors in the design activity.</p><p>If you think at the design process, each time a wrong path is pursued, we get more and more far from the optimal solution. An initial design error, in the wrong hands, will not generate a re-design of the same system, but will lead to the design of another complex solution in order to cope with the initial error. The project, thus, becomes more complex and less efficient at every wrong step.</p><p>The way simplicity can be achieved is to reason in terms of small metal “proof of concepts”, so that a large amount of simple designs can be explored in the mind of the programmer, to start working from something that looks the most viable and direct solution. Later, experience and personal design abilities will allow to improve the design and find sensible solutions for the sub-designs that need to be resolved.</p><p>However each time a complex solution is needed, it’s important to reason for a long time about how the complexity can be avoided, and only continue in that direction if no better possibility is found even considering completely different alternatives.</p><ul><li>Perfectionism, or how to kill your productivity and bias your designs</li></ul><p>Perfectionism comes in two variants: an engineering culture of reaching the best possible measurable performance in a program, and as a personality trait. In both the instances, I see this as one of the biggest barriers for a programmer to deliver things fast. Perfectionism and fear of external judice insert a designing bias that will result in poor choices in order to refine a design only according to psychological or trivially measurable parameters, where things like robustness, simplicity, ability to deliver in time, are often never accounted for. </p><ul><li>Knowledge: some theory is going to help</li></ul><p>When dealing with complex tasks, knowledge about data structures, fundamental limits of computation, non trivial algorithms that are very suitable to model certain tasks, are going to have an impact in the ability to find a suitable design. To be a super expert of everything is not required, but to be at least aware of a multitude of potential solutions for a problem certainly is. For instance applying design sacrifice (accept some error percentage) and being aware of probabilistic set cardinality estimators, can be combined together in order to avoid a complex, slow and memory inefficient solution in order to count unique items in a stream.</p><ul><li>Low level: understanding the machine</li></ul><p>A number of issues in programs, even when using high level languages, arise from the misunderstanding of how the computer is going to perform a given task. This may even lead to the need of re-designing and re-implementing again from scratch a project because there is a fundamental problem in the tools or algorithms used. Good competence of C, the understanding of how CPUs work and clear ideas about how the kernel operates and how system calls are implemented, can save from bad late-stage surprises.</p><ul><li>Debugging skills</li></ul><p>It is very easy to spend an enormous amount of work in order to find bugs. The sum of being good at gaining state about a bug, incrementally, in order to fix it with a rational set of steps, and the attitude of writing simple code that is unlikely to contain too many bugs, can have a great effect on the programmer efficiency.</p><p>It is no surprising to me to see how the above qualities of a programmer can have a 10x impact on the output. Combined they allow for good implementations of designs that start from a viable model and can be several times simpler than alternatives. There is a way to stress simplicity that I like to call “opportunistic programming”. Basically at every development step, the set of features to implement is chosen in order to have the maximum impact on the user base of the program, with the minimum requirement of efforts.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载自 &lt;a href=&quot;http://antirez.com/news/112&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;antirez&gt;&lt;/antirez&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;The-mythical-10x-programmer&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RSS 订阅 arXiv</title>
    <link href="http://yoursite.com/2018/12/30/%E8%AE%A2%E9%98%85-arXiv/"/>
    <id>http://yoursite.com/2018/12/30/订阅-arXiv/</id>
    <published>2018-12-30T12:38:13.000Z</published>
    <updated>2018-12-31T07:17:58.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-订阅"><a href="#1-订阅" class="headerlink" title="1 订阅"></a>1 订阅</h1><h2 id="1-1-步骤"><a href="#1-1-步骤" class="headerlink" title="1.1 步骤"></a>1.1 步骤</h2><ol><li><p>首先，你得确定一下你想订阅哪些：<a href="https://arxiv.org/help/archive_list，以" target="_blank" rel="noopener">https://arxiv.org/help/archive_list，以</a> CS 为例：</p><img src="/2018/12/30/订阅-arXiv/available-list.png" title="CS 这一大类下可订阅的子学科"></li><li><p>注意上图红框的地方，里面的 <strong>cs</strong> 就是我们目的邮箱的名字，也就是说，如果我想订阅 <strong>Computer Science</strong> 这一大类下的文章，就要发邮件给 <strong>cs@arxiv.org</strong></p></li><li><p>开始写邮件</p><ol><li><p>首先是主题，为 <code>subscribe &lt;你的名字&gt;</code> 这样的格式</p></li><li><p>内容：用 <code>add &lt;分类名&gt;</code> 表示增加订阅 &lt;分类名&gt; 类的文章，用 <code>del &lt;分类名&gt;</code> 表示取消订阅 &lt;分类名&gt; 类的文章</p></li><li><p>一封完整的订阅邮件应该是这样的：</p><img src="/2018/12/30/订阅-arXiv/complete-mail.png"><p>这代表我订阅了 <strong>Discrete Mathematics</strong>、<strong>Information Theory</strong>、<strong>Operating Systems</strong>、<strong>Symbolic Computation</strong> 类的文章</p></li></ol></li><li><p>如果成功会受到这样一封邮件</p><img src="/2018/12/30/订阅-arXiv/reply.png"><p>其中 <strong>Artificial Intelligence</strong> 这些刚刚没写的是我之前订阅的</p></li><li><p>如果失败（邮件投递成功，订阅失败）的话会收到一封第一行为 “(No valid add or del options specified.)” 的邮件，这时候就要检查一下标题、命令、分类名称是否正确</p></li><li><p>注意事项：邮件一定要用<font color="red"><strong>纯文本</strong></font>！！！</p></li></ol><h2 id="1-2-获取可订阅列表的另一种方法"><a href="#1-2-获取可订阅列表的另一种方法" class="headerlink" title="1.2 获取可订阅列表的另一种方法"></a>1.2 获取可订阅列表的另一种方法</h2><p>比如我想知道 <strong>Computer Science</strong> 大类下面可订阅的子分类，那么就给相应的邮箱（这里是 <strong>cs@arxiv.org</strong>）发一封标题为 <code>subscribe</code> 的空内容邮件。</p><p>不过这个方法似乎有问题，会返回失败消息。</p><h2 id="1-3-可订阅子分类的缩写名"><a href="#1-3-可订阅子分类的缩写名" class="headerlink" title="1.3 可订阅子分类的缩写名"></a>1.3 可订阅子分类的缩写名</h2><p>这个还没研究过，以后再说。</p><h1 id="2-取消订阅"><a href="#2-取消订阅" class="headerlink" title="2 取消订阅"></a>2 取消订阅</h1><h2 id="2-1-取消订阅某个子分类"><a href="#2-1-取消订阅某个子分类" class="headerlink" title="2.1 取消订阅某个子分类"></a>2.1 取消订阅某个子分类</h2><p>比如我想取消 <strong>Computer Science</strong> 大类下面 <strong>Artificial Intelligence</strong> 分类的订阅，那么就给相应的邮箱（这里是 <strong>cs@arxiv.org</strong>）发送一封带有 <code>del Artificial Intelligence</code> 的邮件，其他同上。</p><h2 id="2-2-取消订阅某个大类"><a href="#2-2-取消订阅某个大类" class="headerlink" title="2.2 取消订阅某个大类"></a>2.2 取消订阅某个大类</h2><p>比如我想取消 <strong>Computer Science</strong> 大类的订阅，那么就给相应的邮箱（这里是 <strong>cs@arxiv.org</strong>） 发送一封标题为 <code>cancel</code> 的空内容邮件。</p><h1 id="再次强调：邮件一定要用纯文本！！！"><a href="#再次强调：邮件一定要用纯文本！！！" class="headerlink" title="再次强调：邮件一定要用纯文本！！！"></a>再次强调：邮件一定要用<font color="red">纯文本</font>！！！</h1><h1 id="3-官方说明"><a href="#3-官方说明" class="headerlink" title="3 官方说明"></a>3 官方说明</h1><p><a href="https://arxiv.org/help/subscribe" target="_blank" rel="noopener">To Subscribe to the E-Mail Alerting Service</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-订阅&quot;&gt;&lt;a href=&quot;#1-订阅&quot; class=&quot;headerlink&quot; title=&quot;1 订阅&quot;&gt;&lt;/a&gt;1 订阅&lt;/h1&gt;&lt;h2 id=&quot;1-1-步骤&quot;&gt;&lt;a href=&quot;#1-1-步骤&quot; class=&quot;headerlink&quot; title=&quot;1.1 步
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在数据库中存储层次结构数据</title>
    <link href="http://yoursite.com/2018/12/30/%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2018/12/30/在数据库中存储层次结构数据/</id>
    <published>2018-12-30T07:37:15.000Z</published>
    <updated>2018-12-30T07:46:18.117Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/12/30/在数据库中存储层次结构数据/bug-report-comments-example.png"><h1 id="邻接（表）模型"><a href="#邻接（表）模型" class="headerlink" title="邻接（表）模型"></a>邻接（表）模型</h1><img src="/2018/12/30/在数据库中存储层次结构数据/adjacency-model.png" title="邻接模型，实际上是一棵 Inverse Tree"><h1 id="嵌套集合模型"><a href="#嵌套集合模型" class="headerlink" title="嵌套集合模型"></a>嵌套集合模型</h1><img src="/2018/12/30/在数据库中存储层次结构数据/nested-sets-model.png"><img src="/2018/12/30/在数据库中存储层次结构数据/nested-sets-model-insert.png"><h1 id="物化路径模型"><a href="#物化路径模型" class="headerlink" title="物化路径模型"></a>物化路径模型</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://www.grayboxpdx.com/blog/post/storing-hierarchical-data-in-a-database" target="_blank" rel="noopener">Storing Hierarchical Data in a Database</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2018/12/30/在数据库中存储层次结构数据/bug-report-comments-example.png&quot;&gt;
&lt;h1 id=&quot;邻接（表）模型&quot;&gt;&lt;a href=&quot;#邻接（表）模型&quot; class=&quot;headerlink&quot; title=&quot;邻接（表）模型&quot;
      
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/Database/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习数学基础 - 概率统计：MLE</title>
    <link href="http://yoursite.com/2018/12/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%EF%BC%9AMLE/"/>
    <id>http://yoursite.com/2018/12/30/机器学习数学基础-概率统计：MLE/</id>
    <published>2018-12-30T03:20:16.000Z</published>
    <updated>2018-12-30T05:55:46.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MLE"><a href="#MLE" class="headerlink" title="MLE"></a>MLE</h1><p>MLE，Maximum Likelihood Estimation，极（最）大似然估计</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MLE&quot;&gt;&lt;a href=&quot;#MLE&quot; class=&quot;headerlink&quot; title=&quot;MLE&quot;&gt;&lt;/a&gt;MLE&lt;/h1&gt;&lt;p&gt;MLE，Maximum Likelihood Estimation，极（最）大似然估计&lt;/p&gt;

      
    
    </summary>
    
      <category term="Math" scheme="http://yoursite.com/categories/Math/"/>
    
      <category term="Machine Learning" scheme="http://yoursite.com/categories/Math/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>动手学深度学习 - 基础篇：Softmax 回归</title>
    <link href="http://yoursite.com/2018/12/29/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9ASoftmax-%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2018/12/29/动手学深度学习-基础篇：Softmax-回归/</id>
    <published>2018-12-29T13:46:11.000Z</published>
    <updated>2019-01-02T05:04:00.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Softmax-回归"><a href="#Softmax-回归" class="headerlink" title="Softmax 回归"></a>Softmax 回归</h1><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>虽然可以使用回归模型建模，并且将预测值就近定点化到分类标签，但是这种连续值到离散值的转化通常会影响到分类质量，因此我们一般使用更加适合离散值输出的模型来解决分类问题。</p><a id="more"></a><h2 id="Softmax-回归模型"><a href="#Softmax-回归模型" class="headerlink" title="Softmax 回归模型"></a>Softmax 回归模型</h2><p>Softmax 回归也是一个单层的神经网络，但是有多个输出神经元，并且其输出层是一个全连接层：</p><img src="/2018/12/29/动手学深度学习-基础篇：Softmax-回归/softmaxreg.svg" title="Softmax 回归是一个单层神经网络"><h3 id="Softmax-运算"><a href="#Softmax-运算" class="headerlink" title="Softmax 运算"></a>Softmax 运算</h3><p>一种直接的办法是直接将输出 $o_i$ 当作类别 $i$ 的置信度，但是存在两个问题：</p><ul><li>输出层的输出值的范围不确定，难以直观地判断这些值的意义<ul><li>比如 $o_1$ = 0.1，$o_2$ = 10，$o_3$ = 0.1，并不能确定较大的值就是最可信的</li></ul></li><li>真实标签是离散值，这些离散值与不确定范围的输出值之间的误差难以衡量</li></ul><p>Softmax 运算符：将输出值变换成值为正且和为 1 的概率分布</p><script type="math/tex; mode=display">\hat{y_1},\hat{y_2},\hat{y_3} = \rm{softmax}(o_1,o_2,o_3)</script><p>其中</p><script type="math/tex; mode=display">\hat{y}_1=\dfrac{exp(o_1)}{\sum_{i=1}^3\exp(o_i)},\hat{y}_2=\dfrac{\exp(o_2)}{\sum_{i=1}^3\exp(o_i)},\hat{y}_3=\dfrac{exp(o_3)}{\sum_{i=1}^3exp(o_i)}</script><p>正确性：</p><script type="math/tex; mode=display">\arg\max\limits_i \hat{y}_i = \arg\max\limits_i \exp(o_i) = \arg\max\limits_i o_i</script><h3 id="计算表达式"><a href="#计算表达式" class="headerlink" title="计算表达式"></a>计算表达式</h3><h4 id="单样本分类的矢量计算表达式"><a href="#单样本分类的矢量计算表达式" class="headerlink" title="单样本分类的矢量计算表达式"></a>单样本分类的矢量计算表达式</h4><script type="math/tex; mode=display">o_1=x_1w_{11}+x_2w_{21} + x_3w_{31} + x_4w_{41} + b_1</script><script type="math/tex; mode=display">o_2=x_1w_{12}+x_2w_{22} + x_3w_{32} + x_4w_{42} + b_2</script><script type="math/tex; mode=display">o_3=x_1w_{13}+x_2w_{23} + x_3w_{33} + x_4w_{43} + b_3</script><script type="math/tex; mode=display">W = \left[\begin{matrix}w_{11} &w_{12}&w_{13} \\ w_{21} &w_{22}&w_{23}\\ w_{31} &w_{32}&w_{33}\\ x_{41}&x_{42}&x_{43}\end{matrix}\right],\ b = [b_1, b_2, b_3]</script><script type="math/tex; mode=display">x^{(i)} = \left[\begin{matrix} x_1^{(i)} & x_2^{(i)} & x_3^{(i)} & x_4^{(i)}\end{matrix}\right]</script><p>输出层输出为</p><script type="math/tex; mode=display">o^{(i)} = \left[\begin{matrix}o_1^{(i)} & o_2^{(i)} & o_3^{(i)}\end{matrix}\right]</script><p>预测概率分布为</p><script type="math/tex; mode=display">\hat{y}^{(i)} = \left[\begin{matrix}\hat{y}_1^{(i)} & \hat{y}_2^{(i)} & \hat{y}_3^{(i)}\end{matrix}\right]</script><p>Softmax 回归对样本 $i$ 分类的矢量计算表达式为</p><script type="math/tex; mode=display">o^{(i)} = x^{(i)}W + b</script><script type="math/tex; mode=display">\hat{y}^{(i)} = {\rm{softmax}}(o^{(i)})</script><h4 id="小样本分类的矢量计算表达式"><a href="#小样本分类的矢量计算表达式" class="headerlink" title="小样本分类的矢量计算表达式"></a>小样本分类的矢量计算表达式</h4><script type="math/tex; mode=display">O =XW + b</script><script type="math/tex; mode=display">\hat{Y} = {\rm{softmax}}(O)</script><h3 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h3><p>分类标签：构造一个向量 $y^{(i)} \in \mathbb{R}^q$，第 $i$ 类的第 $i$ 个数值为 1，其余都为 0。</p><p>损失函数：我们只需要判断某次的分类是不是正确，而不需要判断 Softmax 模型的输出值与实际标签相差多少（太严格，而且缺少合理性），所以这里不使用平方损失函数，而使用更适合衡量两个概率分布差异的测量函数。其中，交叉熵（Cross Entropy）是一个常用的衡量方法：</p><script type="math/tex; mode=display">H(\bold{y}^{(i)},\hat{\bold{y}}^{(i)}) = -\sum\limits_{j=1}^q y_j^{(i)}\log \hat{y}_j^{(i)}</script><p>注意这里 $\bold{y}^{(i)}$ 实际上只有一个元素（第 $y^{(i)}$ 个元素）为 1，也就是说，上面的式子实际上可以简化成下面这样：</p><script type="math/tex; mode=display">H(\bold{y}^{(i)},\hat{\bold{y}}^{(i)}) = -\log  \hat{y}^{(i)}_{y^{(i)}}</script><p>也就是说，交叉熵只关心对正确类别的预测概率，因为只要其值足够大，我们就可以确保分类结果正确。但是需要注意的是，如果一个样本有多个标签，例如图像中含有不止一个物体时，我们并不能做这一步简化，但是实际上也只需要关心图片中出现的物体类别的预测概率。</p><p>交叉熵损失函数：</p><script type="math/tex; mode=display">l(\Theta) = \dfrac{1}{n}\sum\limits_{i=1}^n H(\bold{y}^{(i)},\hat{\bold{y}}^{(i)})</script><p>同时，</p><script type="math/tex; mode=display">\begin{align}l(\Theta)=\dfrac{1}{n}\sum\limits_{i=1}^n H(\bold{y}^{(i)},\hat{\bold{y}}^{(i)})\end{align} = -\dfrac{1}{n}\sum\limits_{i=1}^{n}\log\hat{y}_{y^{(i)}}^{(i)}</script><script type="math/tex; mode=display">-nl(\Theta)=\sum\limits_{i=1}^{n}\log\hat{y}_{y^{(i)}}^{(i)}</script><script type="math/tex; mode=display">\begin{align}\exp(-nl(\Theta)) &= \exp(\sum\limits_{i=1}^{n}\log\hat{y}_{y^{(i)}}^{(i)})\\&=\prod\limits_{i=1}^n\hat{y}_{y^{(i)}}^{(i)}\end{align}</script><p>所以实际上，最小化交叉熵损失函数等价于最大化训练数据集所有标签类别的联合预测概率。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Softmax-回归&quot;&gt;&lt;a href=&quot;#Softmax-回归&quot; class=&quot;headerlink&quot; title=&quot;Softmax 回归&quot;&gt;&lt;/a&gt;Softmax 回归&lt;/h1&gt;&lt;h2 id=&quot;分类问题&quot;&gt;&lt;a href=&quot;#分类问题&quot; class=&quot;headerlink&quot; title=&quot;分类问题&quot;&gt;&lt;/a&gt;分类问题&lt;/h2&gt;&lt;p&gt;虽然可以使用回归模型建模，并且将预测值就近定点化到分类标签，但是这种连续值到离散值的转化通常会影响到分类质量，因此我们一般使用更加适合离散值输出的模型来解决分类问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
      <category term="Basics" scheme="http://yoursite.com/categories/Deep-Learning/Basics/"/>
    
    
  </entry>
  
  <entry>
    <title>Git 内部原理</title>
    <link href="http://yoursite.com/2018/12/29/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/29/Git-内部原理/</id>
    <published>2018-12-29T00:28:24.000Z</published>
    <updated>2018-12-30T15:03:11.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-内部原理"><a href="#Git-内部原理" class="headerlink" title="Git 内部原理"></a>Git 内部原理</h1><p>由于 Git 一开始被设计成共 VCS 使用的工具集而不是一整套用户友好的 VCS，所以实际上它还包含了许多底层命令（Plumbing），像 <code>checkout</code> <code>remote</code> <code>branch</code> 这样的命令被称为 “Porcelain”。</p><a id="more"></a><p><code>git init</code> 产生的 <code>.git</code> 目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.git/</span><br><span class="line">├── hooks/</span><br><span class="line">├── info/</span><br><span class="line">├── objects/</span><br><span class="line">|   ├── info/</span><br><span class="line">|   └── pack/</span><br><span class="line">├── refs/</span><br><span class="line">|   ├── heads/</span><br><span class="line">|   └── tags/</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── HEAD</span><br><span class="line">└── index</span><br></pre></td></tr></table></figure><ul><li><code>description</code> 文件仅供 GitWeb 程序使用</li><li><code>config</code> 文件包含了<strong>项目特有</strong>的配置选项</li><li><code>info</code> 目录保存了一份不希望在 <code>.gitignore</code> 文件中管理的忽略模式（ignored patterns）的全局可执行文件<ul><li><code>exclude</code> 文件</li></ul></li><li><code>hooks</code> 目录保存了客户端或服务端的钩子脚本</li><li>重要的文件和目录：<code>HEAD</code> <code>index</code> <code>objects</code> <code>refs</code><ul><li><code>objects</code> 目录存储所有的数据内容</li><li><code>refs</code> 目录存储指向数据（分支）的提交对象的指针</li><li><code>HEAD</code> 文件指向当前分支</li><li><code>index</code> 文件保存了暂存区信息</li></ul></li></ul><h2 id="Git-对象（objects）"><a href="#Git-对象（objects）" class="headerlink" title="Git 对象（objects）"></a>Git 对象（<code>objects</code>）</h2><p>Git 是一套内容寻址的文件系统，核心上来看不过是简单地存储键值对（key-value），允许插入任意类型的内容，并且会返回一个键值，通过该键值可以在任何时候再取出该内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objects/</span><br><span class="line">├── info/</span><br><span class="line">└── pack/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'test content'</span> | git <span class="built_in">hash</span>-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line"></span><br><span class="line">$ find ./objects</span><br><span class="line">./objects</span><br><span class="line">./objects/d6</span><br><span class="line">./objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">./objects/info</span><br><span class="line">./objects/pack</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'test content 2'</span> | git <span class="built_in">hash</span>-object --stdio</span><br><span class="line">b13c288e945d00a4d16f195b33bf003b53d73dac</span><br><span class="line"></span><br><span class="line">$ find ./objects</span><br><span class="line">./objects</span><br><span class="line">./objects/d6</span><br><span class="line">./objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">./objects/info</span><br><span class="line">./objects/pack</span><br></pre></td></tr></table></figure><ul><li><code>hash-object</code> 命令<ul><li><code>-w</code> 参数指示 <code>hash-object</code> 命令存储数据对象，如果没有这个参数，只返回键值而不存储数据对象</li><li><code>--stdin</code> 指定从 <code>stdin</code> 读取内容，若不指定则需要指定一个要存储的文件的路径</li><li>返回的键值是一个长度为 40 个字符的 SHA-1 校验和，Git 用前 2 个字符为目录名创建一个目录，用剩下的 38 个字符作为文件名在这个目录下创建一个文件<ul><li>如果前两个字符相同怎么办？</li></ul></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line"><span class="built_in">test</span> content</span><br><span class="line"></span><br><span class="line">$ git cat-file -t d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><ul><li><code>cat-file</code> 命令<ul><li>主要参数为对象的校验和（文件名）</li><li><code>-t</code> 参数输出对象的类型，这里是 <code>blob</code><ul><li>BLOB：Binary Large OBject</li></ul></li><li><code>-p</code> 参数指定美观打印</li></ul></li></ul><h3 id="tree-对象"><a href="#tree-对象" class="headerlink" title="tree 对象"></a>tree 对象</h3><p>tree 对象可以存储文件名，也可以存储一组文件。Git 以一种类似 UNIX 文件系统但更简单的方式来存储内容，所有内容以 tree 或 blob 对象存储，tree 对象对应于 UNIX 中的目录，blob 对象则大致对应于 inode 或文件内容。一个单独的 tree 对象包含一条或多条 tree 记录，每一条记录含有一个指向 blob 或子 tree 对象的 SHA-1 指针，并附有该对象的权限模式（mode）、类型和文件名信息。</p><img src="/2018/12/29/Git-内部原理/git-object-model.png" title="Git 对象模型的简化版"><p>通常 Git 根据暂存区域（<code>index</code>    ）来创建并写入一个 tree。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">        test.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br><span class="line"></span><br><span class="line">$ git update-index --add --cacheinfo 100644 \</span><br><span class="line">&gt; 83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   test.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   test.txt</span><br></pre></td></tr></table></figure><ul><li>文件模式<ul><li><code>100644</code> 表明 <code>test.txt</code> 是普通文件</li><li><code>100755</code> 表示可执行文件</li><li><code>120000</code> 表示符号链接</li><li>注意这三种模式仅对 Git 中的文件（Blob）有效</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git write-tree</span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line"></span><br><span class="line">$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">100644 blob 83baae61804e65cc73a7201a7252750c76066a30    test.txt</span><br><span class="line"></span><br><span class="line">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'new file'</span> &gt; new.txt</span><br><span class="line">$ git update-index test.txt</span><br><span class="line">$ git update-index --add new.txt</span><br><span class="line"></span><br><span class="line">$ git write-tree</span><br><span class="line">0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></table></figure><ul><li>如果目标 tree 不存在，调用 <code>write-tree</code> 会自动根据 <code>index</code> 状态创建一个 tree 对象</li><li>注意第一个 <code>cat-file</code> 命令，作为 <code>cat-file</code> 参数的校验和与打印出来的 <code>test.txt</code> 的校验和不同，作为参数的校验和是 tree 对象的校验和</li><li>注意添加完 <code>new.txt</code> 后 <code>car-file</code> 时 <code>test.txt</code> 的校验和（<code>1f7a7a</code>）与之前不同（<code>83baae</code>）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git-内部原理&quot;&gt;&lt;a href=&quot;#Git-内部原理&quot; class=&quot;headerlink&quot; title=&quot;Git 内部原理&quot;&gt;&lt;/a&gt;Git 内部原理&lt;/h1&gt;&lt;p&gt;由于 Git 一开始被设计成共 VCS 使用的工具集而不是一整套用户友好的 VCS，所以实际上它还包含了许多底层命令（Plumbing），像 &lt;code&gt;checkout&lt;/code&gt; &lt;code&gt;remote&lt;/code&gt; &lt;code&gt;branch&lt;/code&gt; 这样的命令被称为 “Porcelain”。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 148：Sort List</title>
    <link href="http://yoursite.com/2018/12/21/LeetCode-148%EF%BC%9ASort-List/"/>
    <id>http://yoursite.com/2018/12/21/LeetCode-148：Sort-List/</id>
    <published>2018-12-21T11:24:08.000Z</published>
    <updated>2018-12-21T11:24:09.531Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LintCode 692：Sliding Window Unique Elements Sum</title>
    <link href="http://yoursite.com/2018/12/18/LintCode-692%EF%BC%9ASliding-Window-Unique-Elements-Sum/"/>
    <id>http://yoursite.com/2018/12/18/LintCode-692：Sliding-Window-Unique-Elements-Sum/</id>
    <published>2018-12-18T12:15:05.000Z</published>
    <updated>2018-12-18T12:37:54.392Z</updated>
    
    <content type="html"><![CDATA[<p>描述</p><p>题目描述：</p><p>给一个数组和一个滑动窗口的大小, 求每一个窗口内唯一元素的个数和</p><p>您在真实的面试中是否遇到过这个题？  是</p><p>题目纠错</p><p>样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给一个数组 nums = [1, 2, 1, 3, 3] 和 k = 3</span><br><span class="line">第一个窗口为 [1, 2, 1], 只有 2 是唯一的, 计数为 1</span><br><span class="line">第二个窗口为 [2, 1, 3], 所有的元素都是唯一的, 计数为 3</span><br><span class="line">第三个窗口为 [1, 3, 3], 只有 1 是唯一的, 计数为 1</span><br><span class="line">总数为 1 + 3 + 1 = 5</span><br><span class="line">返回 5</span><br></pre></td></tr></table></figure><p>不用说，这道题的第一反应一定是枚举每一个窗口，收集其中的元素，并判断。但是可以有更好的解法。</p><p>“滑动窗口” 一个重要的点在于：窗口的每次滑动会导致原来的第一个元素出界，并在窗口的末尾新增一个元素。由此我们可以得到下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingWindowUniqueElementsSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, Integer&gt; counter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = nums.length; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// nums[i - k] 是出界的元素</span></span><br><span class="line">        <span class="keyword">if</span> (i - k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer e : counter.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            counter.put(nums[i - k], counter.get(nums[i - k]) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        counter.put(nums[i], counter.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer e : counter.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="number">1</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个方案有一个问题：每次需要对 <code>Map</code> 进行遍历，这样会很消耗时间，而其实每一次滑动窗口，只引起 <code>Map</code> 的局部变化，遍历是多余的。那么该怎么办呢？思路如下：</p><ul><li>每一次循环都可以在上一次循环 count 增量（下面叫做 <code>delta</code>）的基础上进行增/减</li><li>对于出界的元素<ul><li>如果个数为 1，那么当前唯一的元素就比上一次少 1，即 <code>delta = delta - 1</code></li><li>如果个数为 2，那么由于出界了一个，所以这个元素就变成了唯一的元素，<code>delta = delta + 1</code> </li><li>将出界元素的数量更新（减 1），如果变为 0，则删除</li></ul></li><li>对于新增的元素<ul><li>如果当前的 <code>Map</code> 中不包含这个键，那么他是一个唯一的元素，<code>delta = delta + 1</code></li><li>如果当前的 <code>Map</code> 中已经包含这个键，并且数量为 1（也就是说当初我们把它当作了唯一的元素），那么唯一元素的个数少 1，即 <code>delta = delta - 1</code></li><li>如果当前的 <code>Map</code> 中已经包含这个键，并且数量大于 1，无视</li><li>更新新增元素对应的个数</li></ul></li><li>把 <code>delta</code> 加到 <code>count</code> 上</li><li>需要注意的是，第一个滑动窗口没有上一次增加的结果，所以采用直接的方法即可</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">slidingWindowUniqueElementsSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果滑动窗口的长度为 1，那么每个窗口里的元素一定是唯一的元素</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, Integer&gt; counter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实际上只有第一次需要对 Map 进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">        counter.put(nums[i], counter.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer e : counter.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="number">1</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lastCount = count;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 处理窗口滑动之后出界的元素</span></span><br><span class="line">        <span class="keyword">int</span> c = counter.get(nums[i - k]);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            counter.remove(nums[i-k]);</span><br><span class="line">            lastCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter.put(nums[i - k], counter.get(nums[i - k]) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">2</span>) &#123;</span><br><span class="line">                lastCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理窗口滑动之后新增的元素</span></span><br><span class="line">        <span class="keyword">if</span> (counter.containsKey(nums[i])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter.get(nums[i]) == <span class="number">1</span>) &#123;</span><br><span class="line">                lastCount--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lastCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        counter.put(nums[i], counter.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        count += lastCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;题目描述：&lt;/p&gt;
&lt;p&gt;给一个数组和一个滑动窗口的大小, 求每一个窗口内唯一元素的个数和&lt;/p&gt;
&lt;p&gt;您在真实的面试中是否遇到过这个题？  是&lt;/p&gt;
&lt;p&gt;题目纠错&lt;/p&gt;
&lt;p&gt;样例：&lt;/p&gt;
&lt;figure class=&quot;highlight p
      
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
      <category term="OJ" scheme="http://yoursite.com/categories/Algorithms/OJ/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/Algorithms/OJ/LintCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 128：Longest Consecutive Sequence</title>
    <link href="http://yoursite.com/2018/12/17/LeetCode-128%EF%BC%9ALongest-Consecutive-Sequence/"/>
    <id>http://yoursite.com/2018/12/17/LeetCode-128：Longest-Consecutive-Sequence/</id>
    <published>2018-12-17T13:00:40.000Z</published>
    <updated>2018-12-19T01:37:40.287Z</updated>
    
    <content type="html"><![CDATA[<font color="red">Hard</font><p>题目描述：</p><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为 <strong>O(n)</strong>。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p>这道题如果不限制时间复杂度，是很简单的，排个序，扫描一遍，结束。</p><p>但是限制了时间复杂度，就有点难办了。</p><p>通常 “时间复杂度为 O(n)” 意味着扫描 1 遍整个数组。</p><p>对于示例，考虑这样一个过程：</p><ol><li>遇到 100，没有相邻的数，直接加入容器中</li><li>遇到 4</li><li>遇到 200</li><li>遇到 1</li><li>遇到 3，发现与 4 相邻，建立二者之间的联系</li><li>遇到 2，发现与 1 和 3 相邻，建立联系，这样我们就有了一个关系链：1-2-3-4，它的长度也就是我们要求的结果</li></ol><p>图示：</p><img src="/2018/12/17/LeetCode-128：Longest-Consecutive-Sequence/dynamic.png"><p>这样的关系叫做 “动态等价关系”，而动态等价关系一个很经典的实现就是并查集（Union-Find）（关于动态等价关系和并查集，见 <a href="">动态等价关系：并查集</a>）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font color=&quot;red&quot;&gt;Hard&lt;/font&gt;

&lt;p&gt;题目描述：&lt;/p&gt;
&lt;p&gt;给定一个未排序的整数数组，找出最长连续序列的长度。&lt;/p&gt;
&lt;p&gt;要求算法的时间复杂度为 &lt;strong&gt;O(n)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/stron
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划入门</title>
    <link href="http://yoursite.com/2018/12/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/12/17/动态规划入门/</id>
    <published>2018-12-17T02:25:06.000Z</published>
    <updated>2018-12-17T02:26:17.891Z</updated>
    
    <content type="html"><![CDATA[<p>Dynamic Programming，其中的 “Programming” 并不是 “编程” 的意思，而是 “规划” 的意思。</p><p>动态规划是分治法（Divide and Conquer）的延伸。简单来说就是由于子问题一而再、再而三地出现（recurrence），所以使用表格来记录中间结果，以空间换时间。</p><p>动态规划的过程，就是反复进行 “读取数据 $\rightarrow$ 计算数据 $\rightarrow$ 存储数据”</p><p>需要做的决策：</p><ul><li>计算顺序</li><li>状态空间（总共有哪些问题）</li><li>初始值、计算范围</li></ul><p>主要有两种方式：自顶向下、自底向上</p><p>动态规划的问题有两类：</p><ul><li>计数问题</li><li>极值问题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Dynamic Programming，其中的 “Programming” 并不是 “编程” 的意思，而是 “规划” 的意思。&lt;/p&gt;
&lt;p&gt;动态规划是分治法（Divide and Conquer）的延伸。简单来说就是由于子问题一而再、再而三地出现（recurrence），
      
    
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/categories/Dynamic-Programming/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 142：Linked List Cycle II</title>
    <link href="http://yoursite.com/2018/12/14/LeetCode-142%EF%BC%9ALinked-List-Cycle-II/"/>
    <id>http://yoursite.com/2018/12/14/LeetCode-142：Linked-List-Cycle-II/</id>
    <published>2018-12-14T11:43:28.000Z</published>
    <updated>2018-12-14T12:10:52.157Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p><strong>说明：</strong></p><ul><li>不允许修改给定的链表</li><li>你是否可以不用额外空间解决此题？</li></ul><p><strong>示意图：</strong></p><ul><li><p>有环：</p><img src="/2018/12/14/LeetCode-142：Linked-List-Cycle-II/circular-linked-list.png"></li><li><p>无环：</p><img src="/2018/12/14/LeetCode-142：Linked-List-Cycle-II/no-cycle.png"></li></ul><p>这道题如果使用额外空间的话，是很好做的：用一个容器装所有访问过的结点，如果出现重复，就说明有环。但是如果不使用额外空间呢？</p><p>快慢指针！</p><p>原理是这样的：设环的长度为 $r$，快慢两个指针相遇时走过的长度分别为 $2k$ 和 $k$，那么有 $2k - k = n \cdot r \Rightarrow k = n \cdot r$。假设链表的 <code>head</code> 与环的第一个结点距离为 $s$，链表的 <code>head</code> 与快慢指针相遇点的距离为 $k$，那么环的第一个结点与相遇点的距离为 $m = k - s$，带入，有</p><script type="math/tex; mode=display">s = n \cdot r - m = (n-1) \cdot r + (r-m)</script><p>令 $n = 1$，则有 $s = r - m$，此时快（慢）指针到环的第一个结点的距离与 <code>head</code> 到第一个结点的距离相等，那么二者走同样的步数，相遇点就是环的第一个结点。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            ListNode p = head;</span><br><span class="line">            <span class="keyword">while</span> (p != fast) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h1><p>快慢指针其实还可以做一些其他的事情，就目前的知识，快慢指针还能够找到<strong>单</strong>链表的中点（当然并不会改善复杂度）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mid</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不允许修改给定的链表&lt;/l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 695：Max Area of Island</title>
    <link href="http://yoursite.com/2018/12/14/LeetCode-695%EF%BC%9AMax-Area-of-Island/"/>
    <id>http://yoursite.com/2018/12/14/LeetCode-695：Max-Area-of-Island/</id>
    <published>2018-12-14T08:19:59.000Z</published>
    <updated>2018-12-14T08:19:59.256Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 567：Permutation in String</title>
    <link href="http://yoursite.com/2018/12/14/LeetCode-567%EF%BC%9APermutation-in-String/"/>
    <id>http://yoursite.com/2018/12/14/LeetCode-567：Permutation-in-String/</id>
    <published>2018-12-14T00:41:56.000Z</published>
    <updated>2018-12-14T01:13:07.276Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><p>给定两个字符串 <strong>s1</strong> 和 <strong>s2</strong>，写一个函数来判断 <strong>s2</strong> 是否包含 <strong>s1</strong> 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>输入的字符串只包含小写字母</li><li>两个字符串的长度都在 [1, 10,000] 之间</li></ol><p>思路：这道题刚拿到手通常第一反应是枚举所有的排列情况，然后逐个比对，但是这个方案是超时的。我们再审视一下题目：“第一个字符串的<strong>排列之一</strong>是第二个字符串的子串”，这个 “之一” 意味着 “存在”，即我们实际上不需要知道具体是哪个排列，只要能够验证存在性即可；另一方面，一个序列（Sequence）的所有排列一个最基本的特点就是其中的元素相同（包括种类和个数）。这样，我们就建立起了一个逻辑链条：</p><blockquote><p>​    “第一个字符串的<strong>排列之一</strong>是第二个字符串的子串” $\rightarrow$ 只需要验证存在性，一个序列所有排列的元素相同 $\rightarrow$ 只需要验证是否 <strong>s2</strong> 的某个子串与 <strong>s1</strong> 的元素相同</p></blockquote><p>我们上面说的 “种类” 在这里就是字母，就得到了如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() &gt; s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, Integer&gt; charMap1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : s1.toCharArray()) &#123;</span><br><span class="line">        charMap1.put(ch, charMap1.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    Map&lt;Character, Integer&gt; charMap2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, strLen = s1.length(); i &lt; strLen; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = s2.charAt(i);</span><br><span class="line">        charMap2.put(ch, charMap2.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = s1.length();</span><br><span class="line">    <span class="keyword">while</span> (!charMap1.equals(charMap2)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tail &lt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charMap2.get(s2.charAt(head)) == <span class="number">1</span>) &#123;</span><br><span class="line">                charMap2.remove(s2.charAt(head));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                charMap2.put(s2.charAt(head), </span><br><span class="line">                             charMap2.get(s2.charAt(head)) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            charMap2.put(s2.charAt(tail),</span><br><span class="line">                         charMap2.getOrDefault(s2.charAt(tail), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            head++;</span><br><span class="line">            tail++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那还有没有优化的空间呢？是有的，我们再看题目的要求：“输入的字符串只包含小写字母”，这样我们能够确定这个 “map” 的大小最多是 26，而我们知道字母的字符值很容易转换成从 0 开始的整数值，另外代码中 <code>Map</code> 都是用来计数的，一个整数数组同样可以胜任这件事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] == s2map[i])</span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = s2.charAt(i + s1.length()) - <span class="string">'a'</span>, l = s2.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">26</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            s2map[r]++;</span><br><span class="line">            <span class="keyword">if</span> (s2map[r] == s1map[r])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2map[r] == s1map[r] + <span class="number">1</span>)</span><br><span class="line">                count--;</span><br><span class="line">            s2map[l]--;</span><br><span class="line">            <span class="keyword">if</span> (s2map[l] == s1map[l])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2map[l] == s1map[l] - <span class="number">1</span>)</span><br><span class="line">                count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码其实还可以被进一步地优化，具体可以参见 <a href="https://leetcode.com/problems/permutation-in-string/discuss/102588/Java-Solution-Sliding-Window" target="_blank" rel="noopener">只用一个数组的解法</a></p><p>下面进行技术总结：</p><p>这道题实际上用到了一个叫做 “<a href="https://en.wikipedia.org/wiki/Sliding_window_protocol" target="_blank" rel="noopener">滑动窗口</a>” 的技术。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;p&gt;给定两个字符串 &lt;strong&gt;s1&lt;/strong&gt; 和 &lt;strong&gt;s2&lt;/strong&gt;，写一个函数来判断 &lt;strong&gt;s2&lt;/strong&gt; 是否包含 &lt;strong&gt;s1&lt;/strong&gt; 的排列。&lt;/p&gt;
&lt;p&gt;换句话说，第一个
      
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
      <category term="OJ" scheme="http://yoursite.com/categories/Algorithms/OJ/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/Algorithms/OJ/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 226：Invert Binary Tree</title>
    <link href="http://yoursite.com/2018/12/12/LeetCode-226%EF%BC%9AInvert-Binary-Tree/"/>
    <id>http://yoursite.com/2018/12/12/LeetCode-226：Invert-Binary-Tree/</id>
    <published>2018-12-12T12:02:39.000Z</published>
    <updated>2018-12-12T12:28:12.047Z</updated>
    
    <content type="html"><![CDATA[<p>今天在一个公众号上面看到了一个故事：2015 年，<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 的作者 Max Howell 去面试 Google，据 Max Howell 称，他因为不会一道翻转二叉树被谷歌拒了。下面是大佬的原推：</p><img src="/2018/12/12/LeetCode-226：Invert-Binary-Tree/original-tweet.png"><p>好奇的我去 LeetCode 上搜了一下，还真的有这道题，题目描述是这样的：</p><p>翻转一棵二叉树。</p><p><strong>样例：</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><p>我的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isLeaf(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这里</span></span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.left == <span class="keyword">null</span> &amp;&amp; x.right == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意</strong>的是 <code>TreeNode tmp = root.left</code> 这条语句，直接像下面这样写的话，你就<font color="red"><b>凉</b></font>了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root.left = invertTree(root.right);</span><br><span class="line">root.right = invertTree(root.left);</span><br></pre></td></tr></table></figure><p>输出是这样的：<code>[4,7,7,9,9,9,9]</code>，因为这里是引用，实际上就变成了树的两棵子树都是 <code>root.right</code>。（初学链表时搞不清楚指针的交换顺序也会写出这样的 Bug）</p><p>所以，面试之前先自问一下有没有大佬牛逼，如果没有，就老老实实地刷几遍 LeetCode 或者 LintCode，毕竟这么牛逼的大佬都会因为写不出一道简单的算法题被拒。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在一个公众号上面看到了一个故事：2015 年，&lt;a href=&quot;https://brew.sh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Homebrew&lt;/a&gt; 的作者 Max Howell 去面试 Google，据 Max Howell 称，
      
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
      <category term="OJ" scheme="http://yoursite.com/categories/Algorithms/OJ/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/Algorithms/OJ/LeetCode/"/>
    
    
  </entry>
  
</feed>
