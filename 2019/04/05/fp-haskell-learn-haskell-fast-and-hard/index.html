<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.6 -->
    <script>
        window.materialVersion = "1.5.6"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0',
            '1.5.2',
            '1.5.5'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">









    <link rel="dns-prefetch" href="https://fonts.googleapis.com">





    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            Haskell 极简教程 | 
        
        RHANQTL
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no">
    <meta name="description" itemprop="description" content="声明：本文翻译自 Learn Haskell Fast and Hard

我坚定地相信所有的开发者都应该学习 Haskell。当然，这并不意味着每个人都要变成 Haskell 高手（super Haskell ninjas），但是你至少能发现 Haskell 能给你提供什么。学习 Haskell 能够开阔你的思路。">
    <meta name="keywords" content="">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.en.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?NKhlKQkXw/c66TR5p4wO+w==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="RHANQTL">
    <meta name="msapplication-starturl" content="http://yoursite.com/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="RHANQTL">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://yoursite.com/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Haskell 极简教程 | RHANQTL">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="声明：本文翻译自 Learn Haskell Fast and Hard

我坚定地相信所有的开发者都应该学习 Haskell。当然，这并不意味着每个人都要变成 Haskell 高手（super Haskell ninjas），但是你至少能发现 Haskell 能给你提供什么。学习 Haskell 能够开阔你的思路。">
    

    
        <meta property="article:published_time" content="Fri Apr 05 2019 23:39:40 GMT+0800">
        <meta property="article:modified_time" content="Tue May 07 2019 21:08:33 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://yoursite.com/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/index.html">
    

    <!-- Structured-data for SEO -->
    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span id="MD-burger-id" class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn" class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-绪论"><span class="post-toc-number">1.</span> <span class="post-toc-text">1. 绪论</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-1-安装"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">1.1. 安装</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-2-别害怕"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">1.2. 别害怕</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-3-很基础的-Haskell"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">1.3. 很基础的 Haskell</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-1-函数声明"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">1.3.1. 函数声明</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-2-使用类型的示例"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">1.3.2. 使用类型的示例</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-Essential-Haskell"><span class="post-toc-number">2.</span> <span class="post-toc-text">2. Essential Haskell</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-1-符号"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">2.1. 符号</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-2-函数中有用的符号"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">2.2. 函数中有用的符号</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-困难的部分"><span class="post-toc-number">3.</span> <span class="post-toc-text">3. 困难的部分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-1-函数式风格"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">3.1. 函数式风格</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-1-更高阶的函数"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">3.1.1 更高阶的函数</span></a></li></ol></li></ol></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                Haskell 极简教程
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar">
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Han Qi</strong>
        <span>Apr 05, 2019</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=Haskell 极简教程&url=http://yoursite.com/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/index.html&pic=http://yoursite.com/img/favicon.png&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                شارك على Weibo
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=Haskell 极简教程&url=http://yoursite.com/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/index.html&via=Han Qi" target="_blank">
            <li class="mdl-menu__item">
                شارك على Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/index.html" target="_blank">
            <li class="mdl-menu__item">
                شارك على Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://yoursite.com/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/index.html" target="_blank">
            <li class="mdl-menu__item">
                شارك على Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    
        <a class="post_share-link" href="https://www.linkedin.com/shareArticle?mini=true&url=http://yoursite.com/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/index.html&title=Haskell 极简教程" target="_blank">
            <li class="mdl-menu__item">
                شارك على LinkedIn
            </li>
        </a>
    

    <!-- Share QQ -->
    
        <a class="post_share-link" href="http://connect.qq.com/widget/shareqq/index.html?site=RHANQTL&title=Haskell 极简教程&summary=&pics=http://yoursite.com/img/favicon.png&url=http://yoursite.com/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/index.html" target="_blank">
            <li class="mdl-menu__item">
                شارك على QQ
            </li>
        </a>
    

    <!-- Share Telegram -->
    
        <a class="post_share-link" href="https://telegram.me/share/url?url=http://yoursite.com/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/index.html&text=Haskell 极简教程" target="_blank">
            <li class="mdl-menu__item">
                شارك على Telegram
            </li>
        </a>
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <p><strong>声明：本文翻译自 <a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/" target="_blank" rel="noopener">Learn Haskell Fast and Hard</a></strong></p>
<img src="/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/magritte_pleasure_principle.jpg">
<p>我坚定地相信所有的开发者都应该学习 Haskell。当然，这并不意味着每个人都要变成 Haskell 高手（super Haskell ninjas），但是你至少能发现 Haskell 能给你提供什么。学习 Haskell 能够开阔你的思路。</p>
<a id="more"></a>
<p>主流的编程语言都有如下相同的基础：</p>
<ul>
<li>变量</li>
<li>循环</li>
<li>指针</li>
<li>数据结构、对象和类（大多数主流编程语言是这样）</li>
</ul>
<p>Haskell 很与众不同 —— 它使用了许多我闻所未闻的概念，这些概念能够帮助你成为一名更好的程序员。</p>
<p>但是学习 Haskell 很困难，我曾经就这么觉得。在这篇文章中，我会尝试提供一些在我学习 Haskell 的过程中缺失的东西。</p>
<p>这篇文章很难跟下去，我是故意这样设置的 —— 学习 Haskell 没有捷径，这个过程困难、有挑战性。但是我相信这是一件好事 —— 因为有困难才会有乐趣。</p>
<p>通常，学习 Haskell 都是从 <a href="">Learn You a Haskell</a> 和 <a href="">Real World Haskell</a> 两本书开始的，我也相信这是很正确的方式，但是But to learn what Haskell is all about, 你必须要仔仔细细地阅读它们。</p>
<p>相反，这篇文章是 Haskell 的主要方面的简短、紧凑的概述。我也增加了一些我学习 Haskell 时缺失的信息。</p>
<p>这篇文章由 5 个部分组成：</p>
<ul>
<li><p>绪论：用一个简单示例来说明 Haskell 可以很友好</p>
</li>
<li><p>Haskell 基础知识：Haskell 语法（syntax）和一些重要的概念</p>
</li>
<li><p>困难的部分</p>
<ul>
<li>函数式风格：一个 progressive 的示例，从命令式风格到函数式风格</li>
<li>类型：类型和一个标准二叉树示例</li>
<li>无穷结构：操作无穷二叉树</li>
</ul>
</li>
<li><p>地狱级难度：</p>
<ul>
<li>处理 I/O：一个很小的示例</li>
<li>I/O 技巧解析：理解 I/O 所需要的隐藏的细节</li>
<li>Monad：incredible how we can generalize</li>
</ul>
</li>
<li><p>附录</p>
<ul>
<li><p>关于无穷数的更多信息：关于无穷树的面向数学的讨论</p>
<blockquote>
<p><strong>译者注：</strong>原作者把源代码文件的下载链接放在了分节处，这里直接把下载链接放在相关的位置。可通过如下方式运行（1.2 节中有更详细的说明）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; runhaskell filename.lhs</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>示例代码大多是可以运行的。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h1><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1. 安装"></a>1.1. 安装</h2><img src="/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/Haskell-logo.png">
<p>安装 Haskell 有几种不同的方式，我推荐使用 stack。</p>
<p>还有其他安装的方式，可以在 <a href="https://haskell.org/" target="_blank" rel="noopener">haskell.org</a> 和 <a href="https://haskell-lang.org/" target="_blank" rel="noopener">haskell-lang.org</a> 了解更多。</p>
<p>工具：</p>
<ul>
<li>ghc：类似于 gcc 的 Haskell 编译器</li>
<li>ghci：交互式 Haskell 环境（REPL）</li>
<li>runhaskell：无需编译即可执行程序，很方便，但是与编译后的程序相比很慢</li>
</ul>
<h2 id="1-2-别害怕"><a href="#1-2-别害怕" class="headerlink" title="1.2. 别害怕"></a>1.2. 别害怕</h2><img src="/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/munch_TheScream.jpg">
<p>很多有关 Haskell 的书/文章都从介绍一些深奥的公式开始（快速排序、斐波那契数列等等），我会用完全相反的方式。在一开始，我不会给你展示 Haskell 的任何超能力，而是从它和其他编程语言的相似之处开始。我们先来看看 Haskell 的 “hello world”</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = putStrLn <span class="string">"hello, world"</span></span><br></pre></td></tr></table></figure>
<p>你可以将这段代码存为 “hello.hs” 并且通过如下方式运行：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ runhaskell ./hello.hs</span><br><span class="line"><span class="title">hello</span>, world</span><br></pre></td></tr></table></figure>
<p>或者，你也可以用 stack，先运行 <code>stack setup</code>，然后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ stack runhaskell./hello.hs</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure>
<p>You could also download the literate Haskell source（<a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/00_hello_world.lhs" target="_blank" rel="noopener">点击下载 <code>00_hello_world.lhs</code></a>）. Download this file as <code>00_hello_world.lhs</code> and:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ runhaskell 00_hello_world.lhs</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p>现在，展示一个询问你名字并向你回以 “Hello” 的程序（<a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/10_hello_you.lhs" target="_blank" rel="noopener">点击下载 <code>10_hello_you.lhs</code></a>）：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    print <span class="string">"What is your name?"</span></span><br><span class="line">    name &lt;- getLine</span><br><span class="line">    print(<span class="string">"Hello "</span> ++ name ++ <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure>
<p>首先，让我们将这段代码与一些命令式语言写的相似的代码比较一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"What is your name?"</span></span><br><span class="line">name = raw_input()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Hello %S!"</span> % name</span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ruby</span></span><br><span class="line">puts <span class="string">"What is your name?"</span></span><br><span class="line">name = gets.chomp</span><br><span class="line">puts <span class="string">"Hello <span class="subst">#&#123;name&#125;</span>!"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">666</span>]; <span class="comment">// 一个邪恶的数！</span></span><br><span class="line">    <span class="comment">// 如果我的名字超过 665 字符会怎么样？</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"What is your name?\N"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello %s!\N"</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构是相同的，但是有一些语法差异。这篇教程的主要部分会专门来解释原因。</p>
<p>在 Haskell 中，有一个 <code>main</code> 函数，并且每个对象都有一个类型，<code>main</code> 的类型是 <code>IO ()</code>，这意味着 <code>main</code> 会有副作用（side effect）</p>
<p>记住，Haskell 可以很像主流的命令式语言。</p>
<h2 id="1-3-很基础的-Haskell"><a href="#1-3-很基础的-Haskell" class="headerlink" title="1.3. 很基础的 Haskell"></a>1.3. 很基础的 Haskell</h2><img src="/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/picasso_owl.jpg">
<p>在继续学习 Haskell 之前你需要了解如下的 Haskell 的一些重要性质：</p>
<ul>
<li><p>函数式（Functional）</p>
<p>Haskell 是一个函数式语言。如果你有命令式语言的背景，你会学到很多新的东西，希望这些新的概念甚至在命令式语言中也能够有帮助。</p>
</li>
<li><p>智能的静态类型（Smart Static Typing）</p>
<p>不同于 C、C++、Java，类型系统 is here to help you.</p>
</li>
<li><p>纯净</p>
<p>通常，你的函数不会修改外部的任何东西。这意味着它们不能修改变量的值、不能获取用户输入、不能在屏幕上显示、不能发射导弹。但是另一方面，这样的特性使得并行很容易实现。Haskell makes it clear where effects occur and where your code is pure. Also, it will be far easier to reason about your program. Most bugs will be prevented in the pure parts of your program.</p>
<p>此外，纯函数（pure function）遵循如下的 Haskell 基本法则：</p>
<blockquote>
<p>使用相同的参数调用函数总是得到相同的返回值。</p>
<p>Applying a function with the same parameters always returns the same value.</p>
</blockquote>
</li>
<li><p>惰性（Laziness）</p>
<p>默认是使用惰性是很不常见的语言设计。默认情况下，Haskell 只在需要的时候求值。结果之一是它提供了一种非常优雅的操作无穷结构的方式。</p>
<p>最后一个警告是关于应该如何阅读 Haskell 代码的。对于我来说，这个过程像是阅读科学论文 —— 有些部分很清晰，但是当你看见一个公式时，集中注意力，放慢阅读速度就好。另外，学习 Haskell 时，不理解语法的细节真的问题不大。如果你看到诸如 <code>&gt;&gt;=</code> <code>&lt;$&gt;</code> <code>&lt;-</code> 或者其他奇怪的符号，忽略它们，跟着代码的逻辑流继续就好。</p>
</li>
</ul>
<h3 id="1-3-1-函数声明"><a href="#1-3-1-函数声明" class="headerlink" title="1.3.1. 函数声明"></a>1.3.1. 函数声明</h3><p>你可能习惯了像下面这样的函数声明：</p>
<p>C：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x + y*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x + y*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x + y*y</span><br></pre></td></tr></table></figure>
<p>Ruby：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span></span></span><br><span class="line">    x*x + y*y</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Scheme：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> x y)</span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> x x) (<span class="name"><span class="builtin-name">*</span></span> y y)))</span><br></pre></td></tr></table></figure>
<p>在 Haskell 中，函数声明是这样的：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> x y = x*x + y*y</span><br></pre></td></tr></table></figure>
<p>非常简洁 —— 没有括号，没有 <code>def</code>。</p>
<p>别忘了，Haskell 频繁地使用函数和类型，因此定义它们很容易。The syntax was particularly well thought out for these objects.</p>
<h3 id="1-3-2-使用类型的示例"><a href="#1-3-2-使用类型的示例" class="headerlink" title="1.3.2. 使用类型的示例"></a>1.3.2. 使用类型的示例</h3><p>即使函数的类型信息并不是强制的 —— 因为编译器足够智能，能够自行发现 —— 但是通常会将它们显式地写出来，这样便于理解函数的意图和功能。</p>
<blockquote>
<p><strong>译者注：</strong>这里原文是 “It’s a good idea because it indicates intent and understanding.”</p>
</blockquote>
<p>Let’s play a little. 我们使用 <code>::</code> 来声明类型：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">f</span> x y = x*x + y*y</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print (f <span class="number">2</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/20_very_basic.lhs" target="_blank" rel="noopener">点击下载 20_very_basic.lhs</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ runhaskell 20_very_basic.lhs</span><br><span class="line">13</span><br></pre></td></tr></table></figure>
<p>现在，尝试</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">f</span> x y = x*x + y*x</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print (f <span class="number">2.3</span> <span class="number">4.2</span>)</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/21_very_basic.lhs" target="_blank" rel="noopener">点击下载 21_very_basic.lhs</a></p>
<p>你会得到这样的错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">21_very_basic.lhs:6:23:</span><br><span class="line">    No instance for (Fractional Int)</span><br><span class="line">      arising from the literal `4.2&apos;</span><br><span class="line">    Possible fix: add an instance declaration for (Fractional Int)</span><br><span class="line">    In the second argument of `f&apos;, namely `4.2&apos;</span><br><span class="line">    In the first argument of `print&apos;, namely `(f 2.3 4.2)&apos;</span><br><span class="line">    In the expression: print (f 2.3 4.2)</span><br></pre></td></tr></table></figure>
<p>原因在于 4.2 不是整数。</p>
<p>解决办法：不声明 <code>f</code> 的类型，让 Haskell 自行推断更 general 的类型：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> x y = x*x + y*y</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print (f <span class="number">2.3</span> <span class="number">4.2</span>)</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/22_very_basic.lhs" target="_blank" rel="noopener">点击下载 22_very_basic.lhs</a></p>
<p>现在可以正常运行了！幸运的是，我们不需要为每个特定的类型都声明一个新的函数，例如，在 C 中，你必须要为 <code>int</code> <code>float</code> <code>long</code> <code>double</code> 等等声明各自的函数。</p>
<p>但是，我们应该声明什么类型？为了发现 Haskell 推断出的类型，启动 ghci 并如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ghci</span><br><span class="line">GHCi, version 7.0.4: http://www.haskell.org/ghc/  :? for help</span><br><span class="line">Loading package ghc-prim ... linking ... done.</span><br><span class="line">Loading package integer-gmp ... linking ... done.</span><br><span class="line">Loading package base ... linking ... done.</span><br><span class="line">Loading package ffi-1.0 ... linking ... done.</span><br><span class="line">Prelude&gt; let f x y = x*x + y*y</span><br><span class="line">Prelude&gt; :type f</span><br><span class="line">f :: Num a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>
<p>嗯？这个奇怪的类型是啥？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Num a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>
<p>首先，让我们把注意力集中在右边的 <code>a -&gt; a -&gt; a</code>。要理解它，just look at a list of progressive examples:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型声明</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Int</code></td>
<td><code>Int</code> 类型</td>
</tr>
<tr>
<td><code>Int -&gt; Int</code></td>
<td>从 <code>Int</code> 到 <code>Int</code></td>
</tr>
<tr>
<td><code>Float -&gt; Int</code></td>
<td>从 <code>Float</code> 到 <code>Int</code></td>
</tr>
<tr>
<td><code>a -&gt; Int</code></td>
<td>从任意（any）类型到 <code>Int</code></td>
</tr>
<tr>
<td><code>a -&gt; a</code></td>
<td>从任意类型 <code>a</code> 到相同的类型 <code>a</code></td>
</tr>
<tr>
<td><code>a -&gt; a -&gt; a</code></td>
<td>接受任意类型 <code>a</code> 的两个参数到相同的类型 <code>a</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>译者注：</strong>这种形式的类型声明源于 lambda 演算中的 “<a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">柯里化（Currying）</a>”，马上会演示 Haskell 中的柯里化。</p>
</blockquote>
<p>在类型 <code>a -&gt; a -&gt; a</code> 中，字母 <code>a</code> 是一个<em>类型变量</em>（type variable），表示 <code>f</code> 是有两个参数并且参数和返回值有相同类型的函数。类型变量 <code>a</code> 能够接受许多不同的类型值，例如 <code>Int</code> <code>Integer</code> <code>Float</code> 等等。</p>
<p>所以，不同于像 C 这样的语言中必须有强制的类型（forced type）并且必须为 <code>int</code> <code>long</code> <code>float</code> <code>double</code> 声明各自的函数，我们仅仅需要像动态类型语言中那样声明一个函数。</p>
<p>这种方式有时被叫做参数化多态（parametric polymorphism），也叫做 “鱼和熊掌可以兼得”。</p>
<blockquote>
<p><strong>译者注：</strong>原文为 “having your cake and eating it too”。通常英文中的 “You can’t have your cake and eat it” 会被翻译成 “鱼和熊掌不可兼得”，按照这样的理解，原文可以被翻译成 “鱼和熊掌可以兼得”。而且，参数化多态的优点之一就是既可以有动态类型的简便，也可以在必要时有静态类型的安全性。</p>
</blockquote>
<p>通常情况下 <code>a</code> 可以是任意类型，例如 <code>String</code> 或 <code>Int</code>，但是也可以是复杂类型，例如 <code>Trees</code>，甚至是<u>其他函数</u>等等。</p>
<blockquote>
<p><strong>译者注：</strong>《SICP》中讲到 “程序即数据”，即可以将程序（函数）作为其他函数的参数、变量的值等等。这在主流的动态类型语言（Python、JavaScript）中也有体现，但是个人认为 LisP 和 Haskell 中的形式更为统一，比如 LisP 的方言 Scheme 中 <code>define</code> 既可以用来定义一个常量，也可以用来定义一个函数，Haskell 中也是一样：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> f x y = x*x + y*y</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">let</span> g = <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>Num</code> 是一个<em>类型类</em>（type class），可以将一个类型类理解为一个类型的集合（a set of types）。<code>Num</code> 中只包含行为像数一样的类型（types which behave like numbers），更精确地说，<code>Num</code> 这个类中包含实现了一组特定的函数的类型（<code>Num</code> is class containing types which implement a specific list of functions），尤其是 <code>(*)</code> 和 <code>(+)</code>。</p>
<p>类型类是非常强大的语言构件（construct），我们用它来做一些难以置信的强大的事情，之后会有更多的内容。</p>
<p>最后，<code>Num a =&gt; a -&gt; a -&gt; a</code> 表示：</p>
<p>令 <code>a</code> 为一个属于类型类 <code>Num</code> 的类型，这个函数由类型 <code>a</code> 到 <code>(a -&gt; a)</code>。</p>
<p>确实有点儿奇怪。事实上在 Haskell 中，并不存在真的有两个参数的函数，所有的函数都仅仅有一个参数。但是我们会注意到接受两个参数与先接受第一个参数，返回一个函数，再接受第二个参数是等价的。</p>
<p>更精确地，<code>f 3 4</code> 等价于 <code>(f 3) 4</code>，注意 <code>f 3</code> 是一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f :: Num a =&gt; a -&gt; a -&gt; a</span><br><span class="line"></span><br><span class="line">g :: Num a =&gt; a -&gt; a</span><br><span class="line">g = f 3</span><br></pre></td></tr></table></figure>
<p><code>g y</code> 等价于 <code>3*3 + y*y</code></p>
<p>存在另一个符号表示这样的函数，lambda 符号允许我们创建匿名的函数，如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">g</span> = \y -&gt; <span class="number">3</span>*<span class="number">3</span> + y*y</span><br></pre></td></tr></table></figure>
<p>使用 <code>\</code> 是因为它跟 $\lambda$ 相像并且是 ASCII 字符。</p>
<p>如果你不习惯函数式编程，你的大脑现在应该热起来了（your brain should be starting to heat up）。是时候做出一个真正的应用了。</p>
<p>但是在那之前，我们应该确认类型系统如我们期望的一样工作：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">f</span> x y = x*x + y*y</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print (f <span class="number">3</span> <span class="number">2.4</span>)</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/23_very_basic.lhs" target="_blank" rel="noopener">点击下载 23_very_basic.lhs</a></p>
<p>能够正常运行，因为 3 既是实数（比如 <code>Float</code>）的合法表示也是整数（<code>Int</code>）的合法表示。因为 2.4 是一个实数，3 也会被解释成实数。</p>
<p>如果我们强制我们的函数使用不同的类型工作，会失败：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">f</span> x y = x*x + y*y</span><br><span class="line"></span><br><span class="line"><span class="title">x</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">x</span> = <span class="number">3</span></span><br><span class="line"><span class="title">y</span> :: <span class="type">Float</span></span><br><span class="line"><span class="title">y</span> = <span class="number">2.4</span></span><br><span class="line"><span class="comment">-- 无法运行，因为 x 的类型与 y 的类型不同</span></span><br><span class="line"><span class="title">main</span> = print (f x y)</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/24_very_basic.lhs" target="_blank" rel="noopener">点击下载 24_very_basic.lhs</a></p>
<p>编译器会报错，因为这两个参数必须有相同的类型。</p>
<p>如果你觉得这是个坏主意，认为编译器应该能够自动进行类型转换，你真的应该看看这个（great (and funny)）视频：<a href="https://www.destroyallsoftware.com/talks/wat" target="_blank" rel="noopener">WAT</a></p>
<h1 id="2-Essential-Haskell"><a href="#2-Essential-Haskell" class="headerlink" title="2. Essential Haskell"></a>2. Essential Haskell</h1><img src="/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/kandinsky_gugg.jpg">
<p>我建议你浏览这部分，将它作为参考。Haskell 有很多特性，这里缺少很多信息。当你觉得符号陌生的时候再回来。</p>
<p>我使用 $\Leftrightarrow$ 来表示两个表达式等价（译文中使用 <code>&lt;=&gt;</code>），这是一个元符号（meta notation），Haskell 中并没有 $\Leftrightarrow$，我将会使用 $\Rightarrow$ 来显式表达式的返回值是什么（译文中使用 <code>=&gt;</code>）。</p>
<h2 id="2-1-符号"><a href="#2-1-符号" class="headerlink" title="2.1. 符号"></a>2.1. 符号</h2><ul>
<li><p>算术</p>
<pre>
   3 + 2 * 6 / 3 <=> 3 + ((2*6)/3)
</=></pre>
</li>
<li><p>逻辑</p>
<pre>
    True || False => True
    True && False => False
    True == False => False
    True /= False => True (/=) is the operator for different
</pre>
</li>
<li><p>幂运算</p>
<pre>
    x^n 其中 n 是整型（Integral）（Int 或 Integer）
    x**y 其中 y 是任意类型的数
</pre>


</li>
</ul>
<p>  除了你的电脑的限制之外，<code>Integer</code> 没有其他的限制：</p>
  <pre>
      4^103
      102844034832575377634685573909834406561420991602098741459288064
  </pre>

<p>  很好！Haskell 中也提供有理数（And also rational numbers FTW），但是需要引入 <code>Data.Ratio</code> 模块：</p>
  <pre>
      $ ghci
      ...
      Prelude> :m Data.Ratio
      Data.Ratio> (11 % 15) * (5 % 3)
      11 % 9
  </pre>

<ul>
<li><p>列表</p>
<pre>
    []                       <=> 空列表
    [1, 2, 3]                <=> 整型（Integral）的列表
    ["foo", "bar", "baz"]    <=> 字符串的列表
    1:[2, 3]                 <=> [1, 2, 3]，(:) 在头部增加一个元素
    1:2:[]                   <=> [1, 2]
    [1, 2] ++ [3, 4]         <=> [1, 2, 3, 4]，(++) 连接
    [1, 2, 3] ++ ["foo"]     <=> 错误！ String 不等于 Integral
    [1..4]                   <=> [1, 2, 3, 4]
    [1, 3..10]               <=> [1, 3, 5, 7, 9]
    [2, 3, 5, 7, 11..100]    <=> 错误！我没有那么智能！
    [10, 9..1]               <=> [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
</=></=></=></=></=></=></=></=></=></=></=></pre>
</li>
<li><p>字符串</p>
<p>在 Haskell 中，字符串是 <code>Char</code> 的列表</p>
<pre>
    'a' :: Char
    "a" :: [Char]
    ""    ⇔ []
    "ab"  ⇔ ['a','b'] ⇔  'a':"b" ⇔ 'a':['b'] ⇔ 'a':'b':[]
    "abc" ⇔ "ab"++"c"
</pre>

<blockquote>
<p><strong>注意：</strong>在实际的代码中不应该使用 <code>Char</code> 的列表表示文本，在大多数情况下应该使用 <code>Data.Text</code>。如果想表示 ASCII 字符流，应该使用 <code>Data.ByteString</code>。</p>
</blockquote>
</li>
<li><p>元组（Tuple）</p>
<p>对（couple）的类型是 <code>(a, b)</code>，元组中的元素<u>可以有不同的类型</u>。</p>
<pre>
    -- 所有这些元素都是合法的
    (2, "foo")
    (3, 'a', [2,3])
    ((2, "a"), "c", 3)
</pre>
<pre>
    fst (x, y)       ⇒  x
    snd (x, y)       ⇒  y
    fst (x, y, z)    ⇒  ERROR: fst :: (a,b) -> a
    snd (x, y, z)    ⇒  ERROR: snd :: (a,b) -> b
</pre>
</li>
<li><p>处理括号</p>
<p>你可以使用函数 <code>($)</code> 和 <code>(.)</code> 移除一些括号。</p>
<pre>
    -- 默认：
    f g h x         ⇔  (((f g) h) x)
</pre>
<pre>
    -- $ 会代替从 $ 到表达式末尾的括号
    f g $ h x       ⇔  f g (h x) ⇔ (f g) (h x)
    f $ g h x       ⇔  f (g h x) ⇔ f ((g h) x)
    f $ g $ h x     ⇔  f (g (h x))
</pre>
<pre>
    -- (.) 组合函数
    (f . g) x       ⇔  f (g x)
    (f . g . h) x   ⇔  f (g (h x))
</pre>

</li>
</ul>
<h2 id="2-2-函数中有用的符号"><a href="#2-2-函数中有用的符号" class="headerlink" title="2.2. 函数中有用的符号"></a>2.2. 函数中有用的符号</h2><p>Just a reminder：</p>
<pre>
    x :: Int            ⇔ x 的类型为 Int
    x :: a              ⇔ x 可以是任意类型 a
    x :: Num a => a     ⇔ x 可以是任意属于 Num 类型类的类型 a
    f :: a -> b         ⇔ f 是从 a 到 b 的函数
    f :: a -> b -> c    ⇔ f 是从 a 到 (b→c) 的函数
    f :: (a -> b) -> c  ⇔ f 是从 (a→b) 到 c 的函数
</pre>

<p>记住，Haskell 并不强制要求在函数声明前定义其类型 —— 它会自行推断最 general 的类型 —— 但是这样做是良好的实践（good practice）。</p>
<ul>
<li><p>中缀符号</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">square</span> :: <span class="type">Num</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">square</span> x = x^<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>注意 <code>^</code> 使用了中缀符号。每个中缀运算符都有对应的前缀符号，你要做的仅仅是把它放在括号中：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">square'</span> x = (^) x <span class="number">2</span></span><br><span class="line"><span class="title">square''</span> x = (^<span class="number">2</span>) x</span><br></pre></td></tr></table></figure>
<p>我们可以去掉两边的 <code>x</code>，这叫做 η-规约</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">square'''</span> = (^<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>注意到我们可以在函数的名字中使用 <code>&#39;</code>，这里：</p>
<pre>
    square ⇔ square' ⇔ square'' ⇔ square'''
</pre>
</li>
<li><p>测试</p>
<p>绝对值函数的一个实现：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">absolute</span> :: (<span class="type">Ord</span> a, <span class="type">Num</span> a) =&gt; a -&gt; a</span><br><span class="line"><span class="title">absolute</span> x = <span class="keyword">of</span> x &gt;= <span class="number">0</span> <span class="keyword">then</span> x <span class="keyword">else</span> -x</span><br></pre></td></tr></table></figure>
<p>注意：相比于 <code>if-else</code> 语句，Haskell 中的 <code>if .. then .. else</code> 更像 C 中的三目条件运算符 <code>a ? b : c</code>。<u>不能省略 <code>else</code></u>。</p>
<blockquote>
<p><strong>译者注：</strong>关于不能省略 <code>else</code>，是因为不同于 C、C++、Java 中的 <code>if-else</code>，Haskell 的<code>if-then-else</code> 结构是有返回值的，所以必须保证每种情况都能返回一个值。个人理解，Haskell 的 <code>if-then-else</code> 更像是函数。</p>
</blockquote>
<p>另一个等价的版本：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">absolute'</span> x</span><br><span class="line">    | x &gt;= <span class="number">0</span> = x</span><br><span class="line">    | otherwise = -x</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>译者注：</strong>有点像 Scheme 中的 <code>cond</code> 语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(cond ((or (&gt; x 0) (= x 0)) (x))</span><br><span class="line">&gt;      (else (- 0 x)))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p><strong>符号警告：</strong>就像在 Python 中那样，在 Haskell 中也缩进很重要，不好的缩进可能会破坏你的代码！</p>
</blockquote>
</li>
</ul>
<h1 id="3-困难的部分"><a href="#3-困难的部分" class="headerlink" title="3. 困难的部分"></a>3. 困难的部分</h1><p>困难的部分现在可以开始了。</p>
<h2 id="3-1-函数式风格"><a href="#3-1-函数式风格" class="headerlink" title="3.1. 函数式风格"></a>3.1. 函数式风格</h2><img src="/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/hr_giger_biomechanicallandscape_500.jpg">
<p>在这一节中，我会通过一个简短的例子展示 Haskell 提供的令人印象深刻的重构能力。我们会选择一个问题，并用标准的命令式方式解决它，然后我会令代码演进，得到更加优雅、更易改写的最终结果。</p>
<p>让我们来解决如下的问题：</p>
<p>给定一个整数列表，返回其中偶数的和。</p>
<p>示例：[1, 2, 3, 4, 5] ⇒ 2 + 4 ⇒ 6</p>
<p>为了展示函数式方法和命令式方法的不同，我们从一个命令式解决方案开始（JavaScript）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evenSum</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; list.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list[i] % <span class="number">2</span> ==<span class="number">0</span>) &#123;</span><br><span class="line">            result += list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相反，在 Haskell 中，我们不需要变量或者 for 循环。其中一个不适用循环还能得到相同结果的解决方案是递归。</p>
<blockquote>
<p><strong>注意：</strong>命令式语言中的递归通常被认为是慢的，但是在函数式编程中并不这样。大多数时间 Haskell 能够高效地处理递归函数。</p>
</blockquote>
<p>这是一个 C 版本的递归函数，为了简单起见，假设 <code>int</code> 列表以第一个 0 结尾：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evenSum</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accumSum(<span class="number">0</span>, <span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accumSum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="built_in">list</span> == <span class="number">0</span>) &#123;  <span class="comment">// 如果列表为空</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">list</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> ( (x &amp; <span class="number">0x01</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> accumSum(n+x, <span class="built_in">list</span> + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> accumSum(n, <span class="built_in">list</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住这段代码，我们会把它翻译为 Haskell。然而，首先我需要介绍三个简单但是很有用的函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">even</span> :: <span class="type">Integral</span> a =&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">head</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">tail</span> :: [a] -&gt; [a]</span><br></pre></td></tr></table></figure>
<p><code>even</code> 检测一个数是否是偶数：</p>
<pre>
   even :: Integral a => a -> Bool
   even 3  ⇒ False
   even 2  ⇒ True
</pre>

<p><code>head</code> 返回列表的第一个元素：</p>
<pre>
    head :: [a] -> a
    head [1,2,3] ⇒ 1
    head []      ⇒ ERROR
</pre>

<p><code>tail</code> 返回列表除了第一个以外的所有元素：</p>
<pre>
    tail :: [a] -> [a]
    tail [1,2,3] ⇒ [2,3]
    tail [3]     ⇒ []
    tail []      ⇒ ERROR
</pre>

<p>注意对于任意的非空列表 <code>l</code>，<code>l ⇔ (head l):(tail l)</code>（后面会用到）</p>
<p>第一个 Haskell 解决方案，函数 <code>evenSum</code> 返回列表中所有偶数的和：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Version 1</span></span><br><span class="line"><span class="title">evenSum</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"></span><br><span class="line"><span class="title">evenSum</span> l = accumSum <span class="number">0</span> l</span><br><span class="line"></span><br><span class="line"><span class="title">accumSum</span> n l = <span class="keyword">if</span> l == []</span><br><span class="line">                  <span class="keyword">then</span> n</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">let</span> x = head l</span><br><span class="line">                           xs = tail l</span><br><span class="line">                       <span class="keyword">in</span> <span class="keyword">if</span> even x</span><br><span class="line">                              <span class="keyword">then</span> accumSum (n+x) xs</span><br><span class="line">                              <span class="keyword">else</span> accumSum n xs</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/11_Functions.lhs" target="_blank" rel="noopener">点击下载 11_Functions.lhs</a></p>
<p>可以用 ghci 测试这个函数：</p>
<pre>
    GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
    Loading package ghc-prim ... linking ... done.
    Loading package integer-gmp ... linking ... done.
    Loading package base ... linking ... done.
    Prelude> :load 11_Functions.lhs
    [1 of 1] Compiling Main             ( 11_Functions.lhs, interpreted )
    Ok, modules loaded: Main.
    *Main> evenSum [1..5]
    6
</pre>

<p>这里是一个执行的例子：</p>
<pre>
    *Main> evenSum [1..5]
    accumSum 0 [1,2,3,4,5]
    1 is odd
    accumSum 0 [2,3,4,5]
    2 is even
    accumSum (0+2) [3,4,5]
    3 is odd
    accumSum (0+2) [4,5]
    2 is even
    accumSum (0+2+4) [5]
    5 is odd
    accumSum (0+2+4) []
    l == []
    0+2+4
    0+6
    6
</pre>

<p>从命令式语言改写看起来一切都 OK，不过事实上，还有很多地方可以改进。首先，我们可以泛化函数的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evenSum :: Integral a =&gt; [a] -&gt; a</span><br></pre></td></tr></table></figure>
<p>接下来，我们可以使用子函数，需要用到关键字 <code>where</code> 和 <code>let</code>（<strong>译者注：</strong>其实第一版已经用到了 <code>let</code>），这样我们的 <code>accumSum</code> 函数不会污染（pollute）模块的命名空间：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Version 2</span></span><br><span class="line"><span class="title">evenSum</span> :: <span class="type">Integral</span> a =&gt; [a] -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="title">evenSum</span> l = accumSum <span class="number">0</span> l</span><br><span class="line">    <span class="keyword">where</span> accumSum n l =</span><br><span class="line">            <span class="keyword">if</span> l == []</span><br><span class="line">                <span class="keyword">then</span> n</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">let</span> x = head l</span><br><span class="line">                         xs = tail l</span><br><span class="line">                     <span class="keyword">in</span> <span class="keyword">if</span> even x</span><br><span class="line">                            <span class="keyword">then</span> accumSum (n+x) xs</span><br><span class="line">                            <span class="keyword">else</span> accumSum n xs</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/12_Functions.lhs" target="_blank" rel="noopener">点击下载 12_Functions.lhs</a></p>
<p>接下来，我们使用模式匹配（pattern matching）：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Version 3</span></span><br><span class="line"><span class="title">evenSum</span> l = accumSum <span class="number">0</span> l</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        accumSum n [] = n</span><br><span class="line">        accumSum n (x:xs) =</span><br><span class="line">             <span class="keyword">if</span> even x</span><br><span class="line">                <span class="keyword">then</span> accumSum (n+x) xs</span><br><span class="line">                <span class="keyword">else</span> accumSum n xs</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/13_Functions.lhs" target="_blank" rel="noopener">点击下载 13_Functions.lhs</a></p>
<p>模式匹配是什么？<u>使用值而不是 general 参数名</u>。</p>
<p>相对于 <code>foo l = if l == [] then &lt;x&gt; else &lt;y&gt;</code>，你可以简单地写：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> [] = &lt;x&gt;</span><br><span class="line"><span class="title">foo</span> l  = &lt;y&gt;</span><br></pre></td></tr></table></figure>
<p>但是模式匹配有更强大的功能，它能够见检查复杂值的内部数据。我们可以将</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> l =  <span class="keyword">let</span> x  = head l</span><br><span class="line">             xs = tail l</span><br><span class="line">         <span class="keyword">in</span> <span class="keyword">if</span> even x</span><br><span class="line">             <span class="keyword">then</span> foo (n+x) xs</span><br><span class="line">             <span class="keyword">else</span> foo n xs</span><br></pre></td></tr></table></figure>
<p>替换为</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> (x:xs) = <span class="keyword">if</span> even x</span><br><span class="line">                 <span class="keyword">then</span> foo (n+x) xs</span><br><span class="line">                 <span class="keyword">else</span> foo n xs</span><br></pre></td></tr></table></figure>
<p>这是一个非常有用的特性，使得我们的代码更简洁、更易读。</p>
<p>在 Haskell 中，你能够通过 $\eta$ - 规约简化函数的定义。比如，如下的函数定义：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> x = (some expression) x</span><br></pre></td></tr></table></figure>
<p>可以改写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = some expression</span><br></pre></td></tr></table></figure>
<p>我们使用这种方法移除 <code>l</code>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Version 4</span></span><br><span class="line"><span class="title">evenSum</span> :: <span class="type">Integral</span> a =&gt; [a] -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="title">evenSum</span> = accumSum <span class="number">0</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        accumSum n [] = n</span><br><span class="line">        accumSum n (x:xs) = </span><br><span class="line">            <span class="keyword">if</span> even x</span><br><span class="line">                <span class="keyword">then</span> (n + x) xs</span><br><span class="line">                <span class="keyword">else</span> n xs</span><br></pre></td></tr></table></figure>
<div align="right"><a href="">点此下载 14_Functions.lhs</a></div>

<h3 id="3-1-1-更高阶的函数"><a href="#3-1-1-更高阶的函数" class="headerlink" title="3.1.1 更高阶的函数"></a>3.1.1 更高阶的函数</h3><img src="/2019/04/05/fp-haskell-learn-haskell-fast-and-hard/escher_polygon.png">
<p>to make tings even better，我们应该使用更高阶的函数。这是什么？更高阶的函数是将函数作为参数（parameter）的函数。</p>
<p>示例：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filter</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">foldl</span> :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</span><br></pre></td></tr></table></figure>
<p>继续简化我们的代码：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Version 5</span></span><br><span class="line"><span class="title">evenSum</span> l = mysum <span class="number">0</span> (filter even l)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        mysum n [] = n</span><br><span class="line">        mysum n (x:xs) = mysum (n + x) xs</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<pre>
filter even [1..10] ⇔ [2, 4, 6, 8, 10]
</pre>
函数 `filter` 以一个类型为 `a -> Bool` 的函数和一个类型为 `[a]` 的列表作为参数，并且返回由使谓词为 `true` 的元素组成的列表。

我们的下一步是使用另一种技巧来完成与循环相同的事情。我们使用 `foldl` 函数累加列表（由 `filter` 返回的）中的值。函数 `foldl` 反映一个通用的编码模式：

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myfunc</span> list = foo initialValue list</span><br><span class="line"><span class="title">foo</span> accumulated [] = accumulated</span><br><span class="line"><span class="title">foo</span> tmpValue (x:xs) = foo (bar tmpValue x) xs</span><br></pre></td></tr></table></figure>

可以替换为：

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myfunc</span> list = foldl bar initialValue list</span><br></pre></td></tr></table></figure>

`foldl` 的定义：

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl</span> f z [] = z</span><br><span class="line"><span class="title">foldl</span> f z (x:xs) = foldl f (f z x) xs</span><br></pre></td></tr></table></figure>

<pre>
foldl f z [x1, ... , xn]
⇔ f (... (f (f z x1) x2) ...) xn
</pre>

<p>但是由于 Haskell 是惰性的，它并不计算 <code>(f z x)</code> 的值，仅仅是将它 push 到栈上。这是为什么我们通常使用 <code>foldl&#39;</code> 而不是 <code>foldl</code>，<code>foldl&#39;</code> 是 <code>foldl</code> 的 strict 版本。如果你不理解 lazy 和 strict 是什么意思，别担心，暂时把 <code>foldl</code> 和 <code>foldl&#39;</code> 当成一样的东西。</p>
<p>使用 <code>foldl&#39;</code> 改写的 <code>evenSum</code>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Version 6</span></span><br><span class="line"><span class="comment">-- foldl' 默认不可以访问，需要从 Data.List 模块导入</span></span><br><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"><span class="title">evenSum</span> l = foldl' mysum <span class="number">0</span> (filter even l)</span><br><span class="line">    <span class="keyword">where</span> mysum acc value = acc + value</span><br></pre></td></tr></table></figure>
<p>可以使用 lambda 化简：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- Version 7</span><br><span class="line">-- 通常应该只引入必要的函数</span><br><span class="line">import Data.List (foldl&apos;)</span><br><span class="line">evenSum l = foldl&apos; (\x y -&gt; x + y) 0 (filter even l)</span><br></pre></td></tr></table></figure>
<div align="right"><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/15_Functions.lhs" target="_blank" rel="noopener">点此下载 15_Functions.lhs</a></div>

<p>另外，注意到：</p>
<pre>
(\x y -> x + y) ⇔ (+)
</pre>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Version 8</span></span><br><span class="line"><span class="keyword">import</span> Data.List (<span class="title">foldl'</span>)</span><br><span class="line"><span class="title">evenSum</span> :: <span class="type">Integral</span> a =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">evenSum</span> l = foldl' (+) <span class="number">0</span> (filter even l)</span><br></pre></td></tr></table></figure>
<div align="right"><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/16_Functions.lhs" target="_blank" rel="noopener">点此下载 16_Functions.lhs</a></div>

<p><code>foldl&#39;</code> 并不是最容易把握的函数，如果你还不习惯，you should study it a bit.</p>
<p>为了理解 <code>evenSum</code> 如何工作，看看下面逐步的过程：</p>
<pre>
evenSum [1, 2, 3, 4]
⇒ foldl' (+) 0 (filter even [1, 2, 3, 4])
⇒ foldl' (+) 0 [2, 4]
⇒ foldl' (+) (0 + 2) [4]
⇒ foldl' (+) 2 [4]
⇒ foldl' (+) (2 + 4) []
⇒ foldl' (+) 6 []
⇒ 6
</pre>

<p>另一个有用的高阶函数是 <code>(.)</code>，函数 <code>(.)</code> 对应于数学的组合。</p>
<pre>
(f . g . h) x ⇔ f (g (h x))
</pre>

<p>可以利用 <code>(.)</code> 函数对 <code>evenSum</code> 进行 $\eta$ - 规约：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Version 9</span></span><br><span class="line"><span class="keyword">import</span> Data.List (<span class="title">foldl'</span>)</span><br><span class="line"><span class="title">evenSum</span> :: <span class="type">Integral</span> a =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">evenSum</span> = (foldl' (+) <span class="number">0</span>) . (filter even)</span><br></pre></td></tr></table></figure>
<blockquote>
<pre>
evenSum l = foldl' (+) 0 (filter even l)
          -- l 先与 (filter even) 结合
          = ((foldl' (+) 0) . (filter even)) l
-- 进行 eta-规约
⇒ evenSum = (foldl' (+) 0) . (filter even)
</pre>

</blockquote>
<p>另外，我们可以将某些部分重命名以使代码更清晰：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Version 10</span></span><br><span class="line"><span class="keyword">import</span> Data.List (<span class="title">foldl'</span>)</span><br><span class="line"><span class="title">sum'</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">sum'</span> = foldl' (+) <span class="number">0</span></span><br><span class="line"><span class="title">evenSum</span> :: <span class="type">Integral</span> a =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">evenSum</span> = sum' . (filter even)</span><br></pre></td></tr></table></figure>
<p>It is time to discuss the direction our code has moved as we introduced more functional idioms. 通过使用高阶函数，我们有什么收获？</p>
<p>首先，你可能会认为主要的区别就是高阶函数更加简洁。但事实上，it has more to do with better thinking. 假设我们想要对 <code>evenSum</code> 进行小小的修改，例如，计算所有为偶数的平方之和。</p>
<pre>
[1,2,3,4] ▷ [1,4,9,16] ▷ [4,16] ▷ 20
</pre>
在 Version 10 的基础上修改十分容易：

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">squareEvenSum</span> = sum' . (filter even) . (map(^<span class="number">2</span>))</span><br><span class="line"><span class="title">squareEvenSum</span> = evenSum . (map (^<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

我们刚刚增加了另一个 “转换函数”：

<pre>
map (^2) [1,2,3,4] ⇔ [1,4,9,16]
</pre>

<p><code>map</code> 函数仅仅是对列表中每个元素应用一个函数。</p>
<p>我们不需要修改函数定义内部的任何东西。这使得代码更加模块化。但是你必须要以更加数学化的方式思考你的函数。需要时，You can also use your function interchangably with others。That is, you can compose, map, fold, filter using your new function.</p>
<p>修改 version 1 留给读者作为练习 ☺</p>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2019/04/06/pta-advanced-1003/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            أحدث
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2019/04/03/linux-programming-advanced-network-programming/" id="post_nav-older" class="next-content">
            أقدم
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="Han Qi's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        my@rhanqtl.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="#" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                الرئيسية
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    أرشيف
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2019/12/">December 2019<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/11/">November 2019<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/10/">October 2019<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/09/">September 2019<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/08/">August 2019<span class="sidebar_archives-count">10</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/07/">July 2019<span class="sidebar_archives-count">16</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/06/">June 2019<span class="sidebar_archives-count">21</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/05/">May 2019<span class="sidebar_archives-count">36</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/04/">April 2019<span class="sidebar_archives-count">46</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/03/">March 2019<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/02/">February 2019<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/01/">January 2019<span class="sidebar_archives-count">17</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/12/">December 2018<span class="sidebar_archives-count">26</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/11/">November 2018<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/10/">October 2018<span class="sidebar_archives-count">1</span></a>
            </li></ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material" class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            سمة - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-gplus">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/rhanqtl" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    

    <!-- V2EX -->
    

    <!-- Segmentfault -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;<span year=""></span>&nbsp;RHANQTL
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?Bn9UzEm8RrBSxqyZB0zPjA==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
    
</script>

<!-- MathJax Load-->

    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

    <script type="text/javascript" src="/js/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>




<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    var copyrightNow = new Date().getFullYear();
    var textContent = document.querySelector('span[year]')

    copyrightSince = 0000;
    if (copyrightSince === copyrightNow||copyrightSince === 0000) {
        textContent.textContent = copyrightNow
    } else {
        textContent.textContent = copyrightSince + ' - ' + copyrightNow
    }

    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.6 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
        </body>
    
</html>
