<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="RHANQTL" type="application/atom+xml">






<meta name="description" content="声明：本文翻译自 Learn Haskell Fast and Hard  我坚定地相信所有的开发者都应该学习 Haskell。当然，这并不意味着每个人都要变成 Haskell 高手（super Haskell ninjas），但是你至少能发现 Haskell 能给你提供什么。学习 Haskell 能够开阔你的思路。">
<meta property="og:type" content="article">
<meta property="og:title" content="Haskell 极简教程">
<meta property="og:url" content="http://yoursite.com/2019/04/05/haskell-learn-haskell-fast-and-hard/index.html">
<meta property="og:site_name" content="RHANQTL">
<meta property="og:description" content="声明：本文翻译自 Learn Haskell Fast and Hard  我坚定地相信所有的开发者都应该学习 Haskell。当然，这并不意味着每个人都要变成 Haskell 高手（super Haskell ninjas），但是你至少能发现 Haskell 能给你提供什么。学习 Haskell 能够开阔你的思路。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/04/05/haskell-learn-haskell-fast-and-hard/magritte_pleasure_principle.jpg">
<meta property="og:image" content="http://yoursite.com/2019/04/05/haskell-learn-haskell-fast-and-hard/Haskell-logo.png">
<meta property="og:image" content="http://yoursite.com/2019/04/05/haskell-learn-haskell-fast-and-hard/munch_TheScream.jpg">
<meta property="og:image" content="http://yoursite.com/2019/04/05/haskell-learn-haskell-fast-and-hard/picasso_owl.jpg">
<meta property="og:image" content="http://yoursite.com/2019/04/05/haskell-learn-haskell-fast-and-hard/kandinsky_gugg.jpg">
<meta property="og:image" content="http://yoursite.com/2019/04/05/haskell-learn-haskell-fast-and-hard/hr_giger_biomechanicallandscape_500.jpg">
<meta property="og:updated_time" content="2019-04-06T15:54:00.615Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Haskell 极简教程">
<meta name="twitter:description" content="声明：本文翻译自 Learn Haskell Fast and Hard  我坚定地相信所有的开发者都应该学习 Haskell。当然，这并不意味着每个人都要变成 Haskell 高手（super Haskell ninjas），但是你至少能发现 Haskell 能给你提供什么。学习 Haskell 能够开阔你的思路。">
<meta name="twitter:image" content="http://yoursite.com/2019/04/05/haskell-learn-haskell-fast-and-hard/magritte_pleasure_principle.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/05/haskell-learn-haskell-fast-and-hard/">





  <title>Haskell 极简教程 | RHANQTL</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RHANQTL</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/05/haskell-learn-haskell-fast-and-hard/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RHANQTL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Haskell 极简教程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-05T23:39:40+08:00">
                2019-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p><strong>声明：本文翻译自 <a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/" target="_blank" rel="noopener">Learn Haskell Fast and Hard</a></strong></p>
<img src="/2019/04/05/haskell-learn-haskell-fast-and-hard/magritte_pleasure_principle.jpg">
<p>我坚定地相信所有的开发者都应该学习 Haskell。当然，这并不意味着每个人都要变成 Haskell 高手（super Haskell ninjas），但是你至少能发现 Haskell 能给你提供什么。学习 Haskell 能够开阔你的思路。</p>
<a id="more"></a>
<p>主流的编程语言都有如下相同的基础：</p>
<ul>
<li>变量</li>
<li>循环</li>
<li>指针</li>
<li>数据结构、对象和类（大多数主流编程语言是这样）</li>
</ul>
<p>Haskell 很与众不同 —— 它使用了许多我闻所未闻的概念，这些概念能够帮助你成为一名更好的程序员。</p>
<p>但是学习 Haskell 很困难，我曾经就这么觉得。在这篇文章中，我会尝试提供一些在我学习 Haskell 的过程中缺失的东西。</p>
<p>这篇文章很难跟下去，我是故意这样设置的 —— 学习 Haskell 没有捷径，这个过程困难、有挑战性。但是我相信这是一件好事 —— 因为有困难才会有乐趣。</p>
<p>通常，学习 Haskell 都是从 <a href="">Learn You a Haskell</a> 和 <a href="">Real World Haskell</a> 两本书开始的，我也相信这是很正确的方式，但是But to learn what Haskell is all about, 你必须要仔仔细细地阅读它们。</p>
<p>相反，这篇文章是 Haskell 的主要方面的简短、紧凑的概述。我也增加了一些我学习 Haskell 时缺失的信息。</p>
<p>这篇文章由 5 个部分组成：</p>
<ul>
<li><p>绪论：用一个简单示例来说明 Haskell 可以很友好</p>
</li>
<li><p>Haskell 基础知识：Haskell 语法（syntax）和一些重要的概念</p>
</li>
<li><p>困难的部分</p>
<ul>
<li>函数式风格：一个 progressive 的示例，从命令式风格到函数式风格</li>
<li>类型：类型和一个标准二叉树示例</li>
<li>无穷结构：操作无穷二叉树</li>
</ul>
</li>
<li><p>地狱级难度：</p>
<ul>
<li>处理 I/O：一个很小的示例</li>
<li>I/O 技巧解析：理解 I/O 所需要的隐藏的细节</li>
<li>Monad：incredible how we can generalize</li>
</ul>
</li>
<li><p>附录</p>
<ul>
<li><p>关于无穷数的更多信息：关于无穷树的面向数学的讨论</p>
<blockquote>
<p><strong>译者注：</strong>原作者把源代码文件的下载链接放在了分节处，这里直接把下载链接放在相关的位置。可通过如下方式运行（1.2 节中有更详细的说明）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; runhaskell filename.lhs</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>示例代码大多是可以运行的。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h1><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1. 安装"></a>1.1. 安装</h2><img src="/2019/04/05/haskell-learn-haskell-fast-and-hard/Haskell-logo.png">
<p>安装 Haskell 有几种不同的方式，我推荐使用 stack。</p>
<p>还有其他安装的方式，可以在 <a href="https://haskell.org/" target="_blank" rel="noopener">haskell.org</a> 和 <a href="https://haskell-lang.org/" target="_blank" rel="noopener">haskell-lang.org</a> 了解更多。</p>
<p>工具：</p>
<ul>
<li>ghc：类似于 gcc 的 Haskell 编译器</li>
<li>ghci：交互式 Haskell 环境（REPL）</li>
<li>runhaskell：无需编译即可执行程序，很方便，但是与编译后的程序相比很慢</li>
</ul>
<h2 id="1-2-别害怕"><a href="#1-2-别害怕" class="headerlink" title="1.2. 别害怕"></a>1.2. 别害怕</h2><img src="/2019/04/05/haskell-learn-haskell-fast-and-hard/munch_TheScream.jpg">
<p>很多有关 Haskell 的书/文章都从介绍一些深奥的公式开始（快速排序、斐波那契数列等等），我会用完全相反的方式。在一开始，我不会给你展示 Haskell 的任何超能力，而是从它和其他编程语言的相似之处开始。我们先来看看 Haskell 的 “hello world”</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = putStrLn <span class="string">"hello, world"</span></span><br></pre></td></tr></table></figure>
<p>你可以将这段代码存为 “hello.hs” 并且通过如下方式运行：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ runhaskell ./hello.hs</span><br><span class="line"><span class="title">hello</span>, world</span><br></pre></td></tr></table></figure>
<p>或者，你也可以用 stack，先运行 <code>stack setup</code>，然后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ stack runhaskell./hello.hs</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure>
<p>You could also download the literate Haskell source（<a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/00_hello_world.lhs" target="_blank" rel="noopener">点击下载 <code>00_hello_world.lhs</code></a>）. Download this file as <code>00_hello_world.lhs</code> and:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ runhaskell 00_hello_world.lhs</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p>现在，展示一个询问你名字并向你回以 “Hello” 的程序（<a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/10_hello_you.lhs" target="_blank" rel="noopener">点击下载 <code>10_hello_you.lhs</code></a>）：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    print <span class="string">"What is your name?"</span></span><br><span class="line">    name &lt;- getLine</span><br><span class="line">    print(<span class="string">"Hello "</span> ++ name ++ <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure>
<p>首先，让我们将这段代码与一些命令式语言写的相似的代码比较一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"What is your name?"</span></span><br><span class="line">name = raw_input()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Hello %S!"</span> % name</span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ruby</span></span><br><span class="line">puts <span class="string">"What is your name?"</span></span><br><span class="line">name = gets.chomp</span><br><span class="line">puts <span class="string">"Hello <span class="subst">#&#123;name&#125;</span>!"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">666</span>]; <span class="comment">// 一个邪恶的数！</span></span><br><span class="line">    <span class="comment">// 如果我的名字超过 665 字符会怎么样？</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"What is your name?\N"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello %s!\N"</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构是相同的，但是有一些语法差异。这篇教程的主要部分会专门来解释原因。</p>
<p>在 Haskell 中，有一个 <code>main</code> 函数，并且每个对象都有一个类型，<code>main</code> 的类型是 <code>IO ()</code>，这意味着 <code>main</code> 会有副作用（side effect）</p>
<p>记住，Haskell 可以很像主流的命令式语言。</p>
<h2 id="1-3-很基础的-Haskell"><a href="#1-3-很基础的-Haskell" class="headerlink" title="1.3. 很基础的 Haskell"></a>1.3. 很基础的 Haskell</h2><img src="/2019/04/05/haskell-learn-haskell-fast-and-hard/picasso_owl.jpg">
<p>在继续学习 Haskell 之前你需要了解如下的 Haskell 的一些重要性质：</p>
<ul>
<li><p>函数式（Functional）</p>
<p>Haskell 是一个函数式语言。如果你有命令式语言的背景，你会学到很多新的东西，希望这些新的概念甚至在命令式语言中也能够有帮助。</p>
</li>
<li><p>智能的静态类型（Smart Static Typing）</p>
<p>不同于 C、C++、Java，类型系统 is here to help you.</p>
</li>
<li><p>纯净</p>
<p>通常，你的函数不会修改外部的任何东西。这意味着它们不能修改变量的值、不能获取用户输入、不能在屏幕上显示、不能发射导弹。但是另一方面，这样的特性使得并行很容易实现。Haskell makes it clear where effects occur and where your code is pure. Also, it will be far easier to reason about your program. Most bugs will be prevented in the pure parts of your program.</p>
<p>此外，纯函数（pure function）遵循如下的 Haskell 基本法则：</p>
<blockquote>
<p>使用相同的参数调用函数总是得到相同的返回值。</p>
<p>Applying a function with the same parameters always returns the same value.</p>
</blockquote>
</li>
<li><p>惰性（Laziness）</p>
<p>默认是使用惰性是很不常见的语言设计。默认情况下，Haskell 只在需要的时候求值。结果之一是它提供了一种非常优雅的操作无穷结构的方式。</p>
<p>最后一个警告是关于应该如何阅读 Haskell 代码的。对于我来说，这个过程像是阅读科学论文 —— 有些部分很清晰，但是当你看见一个公式时，集中注意力，放慢阅读速度就好。另外，学习 Haskell 时，不理解语法的细节真的问题不大。如果你看到诸如 <code>&gt;&gt;=</code> <code>&lt;$&gt;</code> <code>&lt;-</code> 或者其他奇怪的符号，忽略它们，跟着代码的逻辑流继续就好。</p>
</li>
</ul>
<h3 id="1-3-1-函数声明"><a href="#1-3-1-函数声明" class="headerlink" title="1.3.1. 函数声明"></a>1.3.1. 函数声明</h3><p>你可能习惯了像下面这样的函数声明：</p>
<p>C：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x + y*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x + y*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x + y*y</span><br></pre></td></tr></table></figure>
<p>Ruby：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span></span></span><br><span class="line">    x*x + y*y</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Scheme：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> x y)</span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> x x) (<span class="name"><span class="builtin-name">*</span></span> y y)))</span><br></pre></td></tr></table></figure>
<p>在 Haskell 中，函数声明是这样的：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> x y = x*x + y*y</span><br></pre></td></tr></table></figure>
<p>非常简洁 —— 没有括号，没有 <code>def</code>。</p>
<p>别忘了，Haskell 频繁地使用函数和类型，因此定义它们很容易。The syntax was particularly well thought out for these objects.</p>
<h3 id="1-3-2-使用类型的示例"><a href="#1-3-2-使用类型的示例" class="headerlink" title="1.3.2. 使用类型的示例"></a>1.3.2. 使用类型的示例</h3><p>即使函数的类型信息并不是强制的 —— 因为编译器足够智能，能够自行发现 —— 但是通常会将它们显式地写出来，这样便于理解函数的意图和功能。</p>
<blockquote>
<p><strong>译者注：</strong>这里原文是 “It’s a good idea because it indicates intent and understanding.”</p>
</blockquote>
<p>Let’s play a little. 我们使用 <code>::</code> 来声明类型：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">f</span> x y = x*x + y*y</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print (f <span class="number">2</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/20_very_basic.lhs" target="_blank" rel="noopener">点击下载 20_very_basic.lhs</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ runhaskell 20_very_basic.lhs</span><br><span class="line">13</span><br></pre></td></tr></table></figure>
<p>现在，尝试</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">f</span> x y = x*x + y*x</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print (f <span class="number">2.3</span> <span class="number">4.2</span>)</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/21_very_basic.lhs" target="_blank" rel="noopener">点击下载 21_very_basic.lhs</a></p>
<p>你会得到这样的错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">21_very_basic.lhs:6:23:</span><br><span class="line">    No instance for (Fractional Int)</span><br><span class="line">      arising from the literal `4.2&apos;</span><br><span class="line">    Possible fix: add an instance declaration for (Fractional Int)</span><br><span class="line">    In the second argument of `f&apos;, namely `4.2&apos;</span><br><span class="line">    In the first argument of `print&apos;, namely `(f 2.3 4.2)&apos;</span><br><span class="line">    In the expression: print (f 2.3 4.2)</span><br></pre></td></tr></table></figure>
<p>原因在于 4.2 不是整数。</p>
<p>解决办法：不声明 <code>f</code> 的类型，让 Haskell 自行推断更 general 的类型：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> x y = x*x + y*y</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print (f <span class="number">2.3</span> <span class="number">4.2</span>)</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/22_very_basic.lhs" target="_blank" rel="noopener">点击下载 22_very_basic.lhs</a></p>
<p>现在可以正常运行了！幸运的是，我们不需要为每个特定的类型都声明一个新的函数，例如，在 C 中，你必须要为 <code>int</code> <code>float</code> <code>long</code> <code>double</code> 等等声明各自的函数。</p>
<p>但是，我们应该声明什么类型？为了发现 Haskell 推断出的类型，启动 ghci 并如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ghci</span><br><span class="line">GHCi, version 7.0.4: http://www.haskell.org/ghc/  :? for help</span><br><span class="line">Loading package ghc-prim ... linking ... done.</span><br><span class="line">Loading package integer-gmp ... linking ... done.</span><br><span class="line">Loading package base ... linking ... done.</span><br><span class="line">Loading package ffi-1.0 ... linking ... done.</span><br><span class="line">Prelude&gt; let f x y = x*x + y*y</span><br><span class="line">Prelude&gt; :type f</span><br><span class="line">f :: Num a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>
<p>嗯？这个奇怪的类型是啥？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Num a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>
<p>首先，让我们把注意力集中在右边的 <code>a -&gt; a -&gt; a</code>。要理解它，just look at a list of progressive examples:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型声明</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Int</code></td>
<td><code>Int</code> 类型</td>
</tr>
<tr>
<td><code>Int -&gt; Int</code></td>
<td>从 <code>Int</code> 到 <code>Int</code></td>
</tr>
<tr>
<td><code>Float -&gt; Int</code></td>
<td>从 <code>Float</code> 到 <code>Int</code></td>
</tr>
<tr>
<td><code>a -&gt; Int</code></td>
<td>从任意（any）类型到 <code>Int</code></td>
</tr>
<tr>
<td><code>a -&gt; a</code></td>
<td>从任意类型 <code>a</code> 到相同的类型 <code>a</code></td>
</tr>
<tr>
<td><code>a -&gt; a -&gt; a</code></td>
<td>接受任意类型 <code>a</code> 的两个参数到相同的类型 <code>a</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>译者注：</strong>这种形式的类型声明源于 lambda 演算中的 “<a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">柯里化（Currying）</a>”，马上会演示 Haskell 中的柯里化。</p>
</blockquote>
<p>在类型 <code>a -&gt; a -&gt; a</code> 中，字母 <code>a</code> 是一个<em>类型变量</em>（type variable），表示 <code>f</code> 是有两个参数并且参数和返回值有相同类型的函数。类型变量 <code>a</code> 能够接受许多不同的类型值，例如 <code>Int</code> <code>Integer</code> <code>Float</code> 等等。</p>
<p>所以，不同于像 C 这样的语言中必须有强制的类型（forced type）并且必须为 <code>int</code> <code>long</code> <code>float</code> <code>double</code> 声明各自的函数，我们仅仅需要像动态类型语言中那样声明一个函数。</p>
<p>这种方式有时被叫做参数化多态（parametric polymorphism），也叫做 “鱼和熊掌可以兼得”。</p>
<blockquote>
<p><strong>译者注：</strong>原文为 “having your cake and eating it too”。通常英文中的 “You can’t have your cake and eat it” 会被翻译成 “鱼和熊掌不可兼得”，按照这样的理解，原文可以被翻译成 “鱼和熊掌可以兼得”。而且，参数化多态的优点之一就是既可以有动态类型的简便，也可以在必要时有静态类型的安全性。</p>
</blockquote>
<p>通常情况下 <code>a</code> 可以是任意类型，例如 <code>String</code> 或 <code>Int</code>，但是也可以是复杂类型，例如 <code>Trees</code>，甚至是<u>其他函数</u>等等。</p>
<blockquote>
<p><strong>译者注：</strong>《SICP》中讲到 “程序即数据”，即可以将程序（函数）作为其他函数的参数、变量的值等等。这在主流的动态类型语言（Python、JavaScript）中也有体现，但是个人认为 LisP 和 Haskell 中的形式更为统一，比如 LisP 的方言 Scheme 中 <code>define</code> 既可以用来定义一个常量，也可以用来定义一个函数，Haskell 中也是一样：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> f x y = x*x + y*y</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">let</span> g = <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>Num</code> 是一个<em>类型类</em>（type class），可以将一个类型类理解为一个类型的集合（a set of types）。<code>Num</code> 中只包含行为像数一样的类型（types which behave like numbers），更精确地说，<code>Num</code> 这个类中包含实现了一组特定的函数的类型（<code>Num</code> is class containing types which implement a specific list of functions），尤其是 <code>(*)</code> 和 <code>(+)</code>。</p>
<p>类型类是非常强大的语言构件（construct），我们用它来做一些难以置信的强大的事情，之后会有更多的内容。</p>
<p>最后，<code>Num a =&gt; a -&gt; a -&gt; a</code> 表示：</p>
<p>令 <code>a</code> 为一个属于类型类 <code>Num</code> 的类型，这个函数由类型 <code>a</code> 到 <code>(a -&gt; a)</code>。</p>
<p>确实有点儿奇怪。事实上在 Haskell 中，并不存在真的有两个参数的函数，所有的函数都仅仅有一个参数。但是我们会注意到接受两个参数与先接受第一个参数，返回一个函数，再接受第二个参数是等价的。</p>
<p>更精确地，<code>f 3 4</code> 等价于 <code>(f 3) 4</code>，注意 <code>f 3</code> 是一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f :: Num a =&gt; a -&gt; a -&gt; a</span><br><span class="line"></span><br><span class="line">g :: Num a =&gt; a -&gt; a</span><br><span class="line">g = f 3</span><br></pre></td></tr></table></figure>
<p><code>g y</code> 等价于 <code>3*3 + y*y</code></p>
<p>存在另一个符号表示这样的函数，lambda 符号允许我们创建匿名的函数，如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">g</span> = \y -&gt; <span class="number">3</span>*<span class="number">3</span> + y*y</span><br></pre></td></tr></table></figure>
<p>使用 <code>\</code> 是因为它跟 $\lambda$ 相像并且是 ASCII 字符。</p>
<p>如果你不习惯函数式编程，你的大脑现在应该热起来了（your brain should be starting to heat up）。是时候做出一个真正的应用了。</p>
<p>但是在那之前，我们应该确认类型系统如我们期望的一样工作：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">f</span> x y = x*x + y*y</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print (f <span class="number">3</span> <span class="number">2.4</span>)</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/23_very_basic.lhs" target="_blank" rel="noopener">点击下载 23_very_basic.lhs</a></p>
<p>能够正常运行，因为 3 既是实数（比如 <code>Float</code>）的合法表示也是整数（<code>Int</code>）的合法表示。因为 2.4 是一个实数，3 也会被解释成实数。</p>
<p>如果我们强制我们的函数使用不同的类型工作，会失败：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">f</span> x y = x*x + y*y</span><br><span class="line"></span><br><span class="line"><span class="title">x</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">x</span> = <span class="number">3</span></span><br><span class="line"><span class="title">y</span> :: <span class="type">Float</span></span><br><span class="line"><span class="title">y</span> = <span class="number">2.4</span></span><br><span class="line"><span class="comment">-- 无法运行，因为 x 的类型与 y 的类型不同</span></span><br><span class="line"><span class="title">main</span> = print (f x y)</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/01_basic/10_Introduction/24_very_basic.lhs" target="_blank" rel="noopener">点击下载 24_very_basic.lhs</a></p>
<p>编译器会报错，因为这两个参数必须有相同的类型。</p>
<p>如果你觉得这是个坏主意，认为编译器应该能够自动进行类型转换，你真的应该看看这个（great (and funny)）视频：<a href="https://www.destroyallsoftware.com/talks/wat" target="_blank" rel="noopener">WAT</a></p>
<h1 id="2-Essential-Haskell"><a href="#2-Essential-Haskell" class="headerlink" title="2. Essential Haskell"></a>2. Essential Haskell</h1><img src="/2019/04/05/haskell-learn-haskell-fast-and-hard/kandinsky_gugg.jpg">
<p>我建议你浏览这部分，将它作为参考。Haskell 有很多特性，这里缺少很多信息。当你觉得符号陌生的时候再回来。</p>
<p>我使用 $\Leftrightarrow$ 来表示两个表达式等价（译文中使用 <code>&lt;=&gt;</code>），这是一个元符号（meta notation），Haskell 中并没有 $\Leftrightarrow$，我将会使用 $\Rightarrow$ 来显式表达式的返回值是什么（译文中使用 <code>=&gt;</code>）。</p>
<h2 id="2-1-符号"><a href="#2-1-符号" class="headerlink" title="2.1. 符号"></a>2.1. 符号</h2><ul>
<li><p>算术</p>
<pre>
   3 + 2 * 6 / 3 <=> 3 + ((2*6)/3)
</=></pre>
</li>
<li><p>逻辑</p>
<pre>
    True || False => True
    True && False => False
    True == False => False
    True /= False => True (/=) is the operator for different
</pre>
</li>
<li><p>幂运算</p>
<pre>
    x^n 其中 n 是整型（Integral）（Int 或 Integer）
    x**y 其中 y 是任意类型的数
</pre>


</li>
</ul>
<p>  除了你的电脑的限制之外，<code>Integer</code> 没有其他的限制：</p>
  <pre>
      4^103
      102844034832575377634685573909834406561420991602098741459288064
  </pre>

<p>  很好！Haskell 中也提供有理数（And also rational numbers FTW），但是需要引入 <code>Data.Ratio</code> 模块：</p>
  <pre>
      $ ghci
      ...
      Prelude> :m Data.Ratio
      Data.Ratio> (11 % 15) * (5 % 3)
      11 % 9
  </pre>

<ul>
<li><p>列表</p>
<pre>
    []                       <=> 空列表
    [1, 2, 3]                <=> 整型（Integral）的列表
    ["foo", "bar", "baz"]    <=> 字符串的列表
    1:[2, 3]                 <=> [1, 2, 3]，(:) 在头部增加一个元素
    1:2:[]                   <=> [1, 2]
    [1, 2] ++ [3, 4]         <=> [1, 2, 3, 4]，(++) 连接
    [1, 2, 3] ++ ["foo"]     <=> 错误！ String 不等于 Integral
    [1..4]                   <=> [1, 2, 3, 4]
    [1, 3..10]               <=> [1, 3, 5, 7, 9]
    [2, 3, 5, 7, 11..100]    <=> 错误！我没有那么智能！
    [10, 9..1]               <=> [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
</=></=></=></=></=></=></=></=></=></=></=></pre>
</li>
<li><p>字符串</p>
<p>在 Haskell 中，字符串是 <code>Char</code> 的列表</p>
<pre>
    'a' :: Char
    "a" :: [Char]
    ""    ⇔ []
    "ab"  ⇔ ['a','b'] ⇔  'a':"b" ⇔ 'a':['b'] ⇔ 'a':'b':[]
    "abc" ⇔ "ab"++"c"
</pre>

<blockquote>
<p><strong>注意：</strong>在实际的代码中不应该使用 <code>Char</code> 的列表表示文本，在大多数情况下应该使用 <code>Data.Text</code>。如果想表示 ASCII 字符流，应该使用 <code>Data.ByteString</code>。</p>
</blockquote>
</li>
<li><p>元组（Tuple）</p>
<p>对（couple）的类型是 <code>(a, b)</code>，元组中的元素<u>可以有不同的类型</u>。</p>
<pre>
    -- 所有这些元素都是合法的
    (2, "foo")
    (3, 'a', [2,3])
    ((2, "a"), "c", 3)
</pre>
<pre>
    fst (x, y)       ⇒  x
    snd (x, y)       ⇒  y
    fst (x, y, z)    ⇒  ERROR: fst :: (a,b) -> a
    snd (x, y, z)    ⇒  ERROR: snd :: (a,b) -> b
</pre>
</li>
<li><p>处理括号</p>
<p>你可以使用函数 <code>($)</code> 和 <code>(.)</code> 移除一些括号。</p>
<pre>
    -- 默认：
    f g h x         ⇔  (((f g) h) x)
</pre>
<pre>
    -- $ 会代替从 $ 到表达式末尾的括号
    f g $ h x       ⇔  f g (h x) ⇔ (f g) (h x)
    f $ g h x       ⇔  f (g h x) ⇔ f ((g h) x)
    f $ g $ h x     ⇔  f (g (h x))
</pre>
<pre>
    -- (.) 组合函数
    (f . g) x       ⇔  f (g x)
    (f . g . h) x   ⇔  f (g (h x))
</pre>

</li>
</ul>
<h2 id="2-2-函数中有用的符号"><a href="#2-2-函数中有用的符号" class="headerlink" title="2.2. 函数中有用的符号"></a>2.2. 函数中有用的符号</h2><p>Just a reminder：</p>
<pre>
    x :: Int            ⇔ x 的类型为 Int
    x :: a              ⇔ x 可以是任意类型 a
    x :: Num a => a     ⇔ x 可以是任意属于 Num 类型类的类型 a
    f :: a -> b         ⇔ f 是从 a 到 b 的函数
    f :: a -> b -> c    ⇔ f 是从 a 到 (b→c) 的函数
    f :: (a -> b) -> c  ⇔ f 是从 (a→b) 到 c 的函数
</pre>

<p>记住，Haskell 并不强制要求在函数声明前定义其类型 —— 它会自行推断最 general 的类型 —— 但是这样做是良好的实践（good practice）。</p>
<ul>
<li><p>中缀符号</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">square</span> :: <span class="type">Num</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">square</span> x = x^<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>注意 <code>^</code> 使用了中缀符号。每个中缀运算符都有对应的前缀符号，你要做的仅仅是把它放在括号中：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">square'</span> x = (^) x <span class="number">2</span></span><br><span class="line"><span class="title">square''</span> x = (^<span class="number">2</span>) x</span><br></pre></td></tr></table></figure>
<p>我们可以去掉两边的 <code>x</code>，这叫做 η-规约</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">square'''</span> = (^<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>注意到我们可以在函数的名字中使用 <code>&#39;</code>，这里：</p>
<pre>
    square ⇔ square' ⇔ square'' ⇔ square'''
</pre>
</li>
<li><p>测试</p>
<p>绝对值函数的一个实现：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">absolute</span> :: (<span class="type">Ord</span> a, <span class="type">Num</span> a) =&gt; a -&gt; a</span><br><span class="line"><span class="title">absolute</span> x = <span class="keyword">of</span> x &gt;= <span class="number">0</span> <span class="keyword">then</span> x <span class="keyword">else</span> -x</span><br></pre></td></tr></table></figure>
<p>注意：相比于 <code>if-else</code> 语句，Haskell 中的 <code>if .. then .. else</code> 更像 C 中的三目条件运算符 <code>a ? b : c</code>。<u>不能省略 <code>else</code></u>。</p>
<blockquote>
<p><strong>译者注：</strong>关于不能省略 <code>else</code>，是因为不同于 C、C++、Java 中的 <code>if-else</code>，Haskell 的<code>if-then-else</code> 结构是有返回值的，所以必须保证每种情况都能返回一个值。个人理解，Haskell 的 <code>if-then-else</code> 更像是函数。</p>
</blockquote>
<p>另一个等价的版本：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">absolute'</span> x</span><br><span class="line">    | x &gt;= <span class="number">0</span> = x</span><br><span class="line">    | otherwise = -x</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>译者注：</strong>有点像 Scheme 中的 <code>cond</code> 语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(cond ((or (&gt; x 0) (= x 0)) (x))</span><br><span class="line">&gt;      (else (- 0 x)))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p><strong>符号警告：</strong>就像在 Python 中那样，在 Haskell 中也缩进很重要，不好的缩进可能会破坏你的代码！</p>
</blockquote>
</li>
</ul>
<h1 id="3-困难的部分"><a href="#3-困难的部分" class="headerlink" title="3. 困难的部分"></a>3. 困难的部分</h1><p>困难的部分现在可以开始了。</p>
<h2 id="3-1-函数式风格"><a href="#3-1-函数式风格" class="headerlink" title="3.1. 函数式风格"></a>3.1. 函数式风格</h2><img src="/2019/04/05/haskell-learn-haskell-fast-and-hard/hr_giger_biomechanicallandscape_500.jpg">
<p>在这一节中，我会通过一个简短的例子展示 Haskell 提供的令人印象深刻的重构能力。我们会选择一个问题，并用标准的命令式方式解决它，然后我会令代码演进，得到更加优雅、更易改写的最终结果。</p>
<p>让我们来解决如下的问题：</p>
<p>给定一个整数列表，返回其中偶数的和。</p>
<p>示例：[1, 2, 3, 4, 5] ⇒ 2 + 4 ⇒ 6</p>
<p>为了展示函数式方法和命令式方法的不同，我们从一个命令式解决方案开始（JavaScript）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evenSum</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; list.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list[i] % <span class="number">2</span> ==<span class="number">0</span>) &#123;</span><br><span class="line">            result += list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相反，在 Haskell 中，我们不需要变量或者 for 循环。其中一个不适用循环还能得到相同结果的解决方案是递归。</p>
<blockquote>
<p><strong>注意：</strong>命令式语言中的递归通常被认为是慢的，但是在函数式编程中并不这样。大多数时间 Haskell 能够高效地处理递归函数。</p>
</blockquote>
<p>这是一个 C 版本的递归函数，为了简单起见，假设 <code>int</code> 列表以第一个 0 结尾：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evenSum</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accumSum(<span class="number">0</span>, <span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accumSum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="built_in">list</span> == <span class="number">0</span>) &#123;  <span class="comment">// 如果列表为空</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">list</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> ( (x &amp; <span class="number">0x01</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> accumSum(n+x, <span class="built_in">list</span> + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> accumSum(n, <span class="built_in">list</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住这段代码，我们会把它翻译为 Haskell。然而，首先我需要介绍三个简单但是很有用的函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">even</span> :: <span class="type">Integral</span> a =&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">head</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">tail</span> :: [a] -&gt; [a]</span><br></pre></td></tr></table></figure>
<p><code>even</code> 检测一个数是否是偶数：</p>
<pre>
   even :: Integral a => a -> Bool
   even 3  ⇒ False
   even 2  ⇒ True
</pre>

<p><code>head</code> 返回列表的第一个元素：</p>
<pre>
    head :: [a] -> a
    head [1,2,3] ⇒ 1
    head []      ⇒ ERROR
</pre>

<p><code>tail</code> 返回列表除了第一个以外的所有元素：</p>
<pre>
    tail :: [a] -> [a]
    tail [1,2,3] ⇒ [2,3]
    tail [3]     ⇒ []
    tail []      ⇒ ERROR
</pre>

<p>注意对于任意的非空列表 <code>l</code>，<code>l ⇔ (head l):(tail l)</code>（后面会用到）</p>
<p>第一个 Haskell 解决方案，函数 <code>evenSum</code> 返回列表中所有偶数的和：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Version 1</span></span><br><span class="line"><span class="title">evenSum</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"></span><br><span class="line"><span class="title">evenSum</span> l = accumSum <span class="number">0</span> l</span><br><span class="line"></span><br><span class="line"><span class="title">accumSum</span> n l = <span class="keyword">if</span> l == []</span><br><span class="line">                  <span class="keyword">then</span> n</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">let</span> x = head l</span><br><span class="line">                           xs = tail l</span><br><span class="line">                       <span class="keyword">in</span> <span class="keyword">if</span> even x</span><br><span class="line">                              <span class="keyword">then</span> accumSum (n+x) xs</span><br><span class="line">                              <span class="keyword">else</span> accumSum n xs</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/11_Functions.lhs" target="_blank" rel="noopener">点击下载 11_Functions.lhs</a></p>
<p>可以用 ghci 测试这个函数：</p>
<pre>
    GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
    Loading package ghc-prim ... linking ... done.
    Loading package integer-gmp ... linking ... done.
    Loading package base ... linking ... done.
    Prelude> :load 11_Functions.lhs
    [1 of 1] Compiling Main             ( 11_Functions.lhs, interpreted )
    Ok, modules loaded: Main.
    *Main> evenSum [1..5]
    6
</pre>

<p>这里是一个执行的例子：</p>
<pre>
    *Main> evenSum [1..5]
    accumSum 0 [1,2,3,4,5]
    1 is odd
    accumSum 0 [2,3,4,5]
    2 is even
    accumSum (0+2) [3,4,5]
    3 is odd
    accumSum (0+2) [4,5]
    2 is even
    accumSum (0+2+4) [5]
    5 is odd
    accumSum (0+2+4) []
    l == []
    0+2+4
    0+6
    6
</pre>

<p>从命令式语言改写看起来一切都 OK，不过事实上，还有很多地方可以改进。首先，我们可以泛化函数的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evenSum :: Integral a =&gt; [a] -&gt; a</span><br></pre></td></tr></table></figure>
<p>接下来，我们可以使用子函数，需要用到关键字 <code>where</code> 和 <code>let</code>（<strong>译者注：</strong>其实第一版已经用到了 <code>let</code>），这样我们的 <code>accumSum</code> 函数不会污染（pollute）模块的命名空间：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Version 2</span></span><br><span class="line"><span class="title">evenSum</span> :: <span class="type">Integral</span> a =&gt; [a] -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="title">evenSum</span> l = accumSum <span class="number">0</span> l</span><br><span class="line">    <span class="keyword">where</span> accumSum n l =</span><br><span class="line">            <span class="keyword">if</span> l == []</span><br><span class="line">                <span class="keyword">then</span> n</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">let</span> x = head l</span><br><span class="line">                         xs = tail l</span><br><span class="line">                     <span class="keyword">in</span> <span class="keyword">if</span> even x</span><br><span class="line">                            <span class="keyword">then</span> accumSum (n+x) xs</span><br><span class="line">                            <span class="keyword">else</span> accumSum n xs</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/12_Functions.lhs" target="_blank" rel="noopener">点击下载 12_Functions.lhs</a></p>
<p>接下来，我们使用模式匹配（pattern matching）：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Version 3</span></span><br><span class="line"><span class="title">evenSum</span> l = accumSum <span class="number">0</span> l</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        accumSum n [] = n</span><br><span class="line">        accumSum n (x:xs) =</span><br><span class="line">             <span class="keyword">if</span> even x</span><br><span class="line">                <span class="keyword">then</span> accumSum (n+x) xs</span><br><span class="line">                <span class="keyword">else</span> accumSum n xs</span><br></pre></td></tr></table></figure>
<p><a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/code/02_Hard_Part/13_Functions.lhs" target="_blank" rel="noopener">点击下载 13_Functions.lhs</a></p>
<p>模式匹配是什么？<u>使用值而不是 general 参数名</u>。</p>
<p>相对于 <code>foo l = if l == [] then &lt;x&gt; else &lt;y&gt;</code>，你可以简单地写：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> [] = &lt;x&gt;</span><br><span class="line"><span class="title">foo</span> l  = &lt;y&gt;</span><br></pre></td></tr></table></figure>
<p>但是模式匹配有更强大的功能，它能够见检查复杂值的内部数据。我们可以将</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> l =  <span class="keyword">let</span> x  = head l</span><br><span class="line">             xs = tail l</span><br><span class="line">         <span class="keyword">in</span> <span class="keyword">if</span> even x</span><br><span class="line">             <span class="keyword">then</span> foo (n+x) xs</span><br><span class="line">             <span class="keyword">else</span> foo n xs</span><br></pre></td></tr></table></figure>
<p>替换为</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> (x:xs) = <span class="keyword">if</span> even x</span><br><span class="line">                 <span class="keyword">then</span> foo (n+x) xs</span><br><span class="line">                 <span class="keyword">else</span> foo n xs</span><br></pre></td></tr></table></figure>
<p>这是一个非常有用的特性，使得我们的代码更简洁、更易读。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/03/linux-programming-advanced-network-programming/" rel="next" title="Linux 程序设计 - 进阶篇：网络编程">
                <i class="fa fa-chevron-left"></i> Linux 程序设计 - 进阶篇：网络编程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/06/pta-advanced-1003/" rel="prev" title="PTA 甲级 1003：Emergency">
                PTA 甲级 1003：Emergency <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Han Qi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">83</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-绪论"><span class="nav-number">1.</span> <span class="nav-text">1. 绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-安装"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. 安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-别害怕"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. 别害怕</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-很基础的-Haskell"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. 很基础的 Haskell</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-函数声明"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1. 函数声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-使用类型的示例"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2. 使用类型的示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Essential-Haskell"><span class="nav-number">2.</span> <span class="nav-text">2. Essential Haskell</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-符号"><span class="nav-number">2.1.</span> <span class="nav-text">2.1. 符号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-函数中有用的符号"><span class="nav-number">2.2.</span> <span class="nav-text">2.2. 函数中有用的符号</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-困难的部分"><span class="nav-number">3.</span> <span class="nav-text">3. 困难的部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-函数式风格"><span class="nav-number">3.1.</span> <span class="nav-text">3.1. 函数式风格</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Han Qi</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
